
/* ------------------------- PRODUCT DATA ------------------------- */
const productData = {
    "DOOR LOCK": {
        title: "Door Lock",
        desc: "Smart door locks with multiple access methods.",
        subProducts: {
            "DS811": {
                title: "DS811",
                desc: "Smart door lock with multiple access methods",
                img: "./images/doorlock/7.png",
                features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App", "Doorbell"]
            },
            "DG10S": {
                title: "DG10S",
                desc: "Advanced smart door lock",
                img: "./images/doorlock/8.png",
                features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App", "Doorbell"]
            },
            "DMSGSERIES": {
                title: "DMSGSERIES",
                desc: "Premium smart door lock series",
                img: "./images/doorlock/9.png",
                features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App"]
            },
            "DS605": {
                title: "DS605",
                desc: "Compact smart door lock",
                img: "./images/doorlock/10.png",
                features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App", "Doorbell"]
            },
            "DS923MAX": {
                title: "DS923MAX",
                desc: "Maximum security door lock",
                img: "./images/doorlock/11.png",
                features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App", "Doorbell"]
            },
            "DMFASL53": {
                title: "DMFASL53",
                desc: "Advanced fingerprint door lock",
                img: "./images/doorlock/12.png",
                features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App", "Doorbell"]
            },
            "DMSASL54": {
                title: "DMSASL54",
                desc: "Smart access door lock",
                img: "./images/doorlock/13.png",
                features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App", "Doorbell"]
            },
            "DS812": {
                title: "DS812",
                desc: "Multi-access door lock",
                img: "./images/doorlock/14.png",
                features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App", "Doorbell"]
            },
            "DMSSL56": {
                title: "DMSSL56",
                desc: "Smart lock with advanced features",
                img: "./images/doorlock/15.png",
                features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App"]
            },
            "DMRSL55": {
                title: "DMRSL55",
                desc: "Reliable smart door lock",
                img: "./images/doorlock/16.png",
                features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App"]
            },
            "DMSSL57": {
                title: "DMSSL56",
                desc: "Smart lock with advanced features",
                img: "./images/doorlock/17.png",
                features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App"]
            },
            "DMSSL58": {
                title: "DMSSL58",
                desc: "Secure smart lock system",
                img: "./images/doorlock/18.png",
                features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App"]
            },
            "DMFSL": {
                title: "DMFSL",
                desc: "Fingerprint smart lock",
                img: "./images/doorlock/19.png",
                features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App"]
            },
            "DMRSL59": {
                title: "DMRSL59",
                desc: "Advanced smart lock",
                img: "./images/doorlock/20.png",
                features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App"]
            }
        }
    },
    "PROCESSOR": {
        title: "Processor",
        desc: "High-performance automation processors.",
        subProducts: {
            "LUMI MINI": {
                title: "LUMI MINI",
                desc: "Intel N2830 Dual Core, 4GB RAM + 128GB SSD, dual USB 2.0 & 3.0 ports, compact aluminium body, Gigabit Ethernet & Wi-Fi.",
                img: "./images/processor/21.png",
                features: ["Intel N2830 Dual Core", "4GB RAM + 128GB SSD", "Dual USB 2.0 & 3.0 ports", "Compact aluminium body", "Gigabit Ethereum & Wi-Fi"]
            },
            "LUMI PLUS": {
                title: "LUMI PLUS",
                desc: "Intel N5105 (2.0â€“2.9 GHz), 8GB RAM + 128GB SSD, dual USB 2.0 & USB 3.0 ports, compact plastic body, Gigabit Ethernet & Wi-Fi.",
                img: "./images/processor/22.png",
                features: ["Intel N5105 (2.0â€“2.9 GHz)", "8GB RAM + 128GB SSD", "Dual USB 2.0 & USB 3.0 ports", "Compact plastic body", "Gigabit Ethereum & Wi-Fi"]
            },
            "LUMI ULTRA": {
                title: "LUMI ULTRA",
                desc: "Intel i7 (2.8â€“4.7 GHz), 16GB RAM + 256GB SSD, aluminium body, dual USB 2.0 & USB 3.0 ports, Gigabit Ethereum & Wi-Fi.",
                img: "./images/processor/23.png",
                features: ["Intel i7 (2.8â€“4.7 GHz)", "16GB RAM + 256GB SSD", "Aluminium body", "Dual USB 2.0 & USB 3.0 ports", "Gigabit Ethereum & Wi-Fi"]
            }
        }
    },
    "LUMI GLASS SERIES": {
        title: "LUMI Glass Series",
        desc: "Modular glass touch panels in multiple model sizes.",
        subProducts: {
            "2 MODEL": {
                title: "2 MODEL",
                desc: "Frame size 85Ã—85Ã—8 mm, fits 2M box, available in black & white glass colours.",
                img: "./images/lumiglass/24.png",
                features: ["Frame size 85Ã—85Ã—8 mm", "Fits 2M box", "Black & white glass colours"]
            },
            "4 MODEL": {
                title: "4 MODEL",
                desc: "Frame size 150Ã—85Ã—8 mm, 4M variants (2 Quads / 1 Quad + 1 Blank), fits 4M box, available in black & white glass colours.",
                img: "./images/lumiglass/25.png",
                features: ["Frame size 150Ã—85Ã—8 mm", "4M variants (2 Quads / 1 Quad + 1 Blank)", "Fits 4M box", "Black & white glass colours"]
            },
            "6 MODEL": {
                title: "6 MODEL",
                desc: "Frame size 220Ã—85Ã—8 mm, 6M variants (3 Quads / 2 Quads + 1 Blank / 1 Quad + 2 Blanks), fits 6M box, available in black & white glass colours.",
                img: "./images/lumiglass/26.png",
                features: ["Frame size 220Ã—85Ã—8 mm", "6M variants", "Fits 6M box", "Black & white glass colours"]
            },
            "8 MODEL": {
                title: "8 MODEL",
                desc: "Frame size 240Ã—90Ã—8 mm, 8M variants (3 Quads / 2 Quads + 1 Blank / 1 Quad + 2 Blanks), fits 8M box, available in black & white glass colours.",
                img: "./images/lumiglass/26.png",
                features: ["Frame size 240Ã—90Ã—8 mm", "8M variants", "Fits 8M box", "Black & white glass colours"]
            },
            "12 MODEL": {
                title: "12 MODEL",
                desc: "Frame size 220Ã—155Ã—8 mm, 12M variant (3 Quads + 3 Blanks), fits 12M box, available in black & white glass colours.",
                img: "./images/lumiglass/27.png",
                features: ["Frame size 220Ã—155Ã—8 mm", "12M variant (3 Quads + 3 Blanks)", "Fits 12M box", "Black & white glass colours"]
            }
        }
    },
    "ESCULT SERIES": {
        title: "Escult Series",
        desc: "Designer sculpted smart touch panels.",
        subProducts: {
            "2 MODEL": {
                title: "2 MODEL",
                desc: "Board size 114Ã—86Ã—9 mm, fits 2M box, available in 9 Colors and 27 Finish",
                img: "./images/escultseries/28.png",
                features: ["Board size 114Ã—86Ã—9 mm", "Fits 2M box", "9 Colors", "27 Finish"]
            },
            "4 MODEL": {
                title: "4 MODEL",
                desc: "Board size 174Ã—86Ã—9 mm, fits 4M box, available in 9 Colors and 27 Finish",
                img: "./images/escultseries/29.png",
                features: ["Board size 174Ã—86Ã—9 mm", "Fits 4M box", "9 Colors", "27 Finish"]
            },
            "6 MODEL": {
                title: "6 MODEL",
                desc: "Board size 250Ã—86Ã—9 mm, fits 6M box, available in 9 Colors and 27 Finish",
                img: "./images/escultseries/30.png",
                features: ["Board size 250Ã—86Ã—9 mm", "Fits 6M box", "9 Colors", "27 Finish"]
            },
            "8 MODEL": {
                title: "8 MODEL",
                desc: "Board size 250Ã—86Ã—9 mm, fits 8M box, available in 9 Colors and 27 Finish",
                img: "./images/escultseries/30.png",
                features: ["Board size 250Ã—86Ã—9 mm", "Fits 8M box", "9 Colors", "27 Finish"]
            }
        }
    },
    "WALL MOUNT DISPLAY": {
        title: "Wall Mount Display",
        desc: "Android-powered wall mount tablets.",
        subProducts: {
            "10\" POE ANDROID WALL MOUNT TABLET": {
                title: "10\" POE ANDROID WALL MOUNT TABLET",
                desc: "RK3566 Quad-core, Android 11, 4GB RAM + 16GB ROM, 10\" IPS display (800Ã—1280, 500 nits), PoE & 12V power, USB-C & RS485, Wi-Fi/Bluetooth/Ethernet, durable metal body.",
                img: "./images/walldisplay/37.png",
                features: ["RK3566 Quad-core", "Android 11", "4GB RAM + 16GB ROM", "10\" IPS display (800Ã—1280, 500 nits)", "PoE & 12V power", "USB-C & RS485", "Wi-Fi/Bluetooth/Ethernet", "Durable metal body"]
            },
            "4\" POE ANDROID WALL MOUNT TABLET": {
                title: "4\" POE ANDROID WALL MOUNT TABLET",
                desc: "RK3566 Quad-core, Android 11, 2GB RAM + 16GB ROM, 4\" IPS display (480Ã—480), PoE & AC power, USB-C/RS485/Speaker/Mic, Wi-Fi/Bluetooth/Ethernet, durable in-wall design (White/Black).",
                img: "./images/walldisplay/36.png",
                features: ["RK3566 Quad-core", "Android 11", "2GB RAM + 16GB ROM", "4\" IPS display (480Ã—480)", "PoE & AC power", "USB-C/RS485/Speaker/Mic", "Wi-Fi/Bluetooth/Ethernet", "Durable in-wall design (White/Black)"]
            }
        }
    },
    "TACTILE HEXA SERIES": {
        title: "Tactile Hexa Series",
        desc: "Premium tactile switches and controls.",
        subProducts: {
            "6 BUTTON KNX SWITCH": {
                title: "6 BUTTON KNX SWITCH",
                desc: "KNX BUS protocol, CNC metal build, 21â€“30 VDC input, max 90% humidity, 86Ã—86Ã—24 mm size, â€“5Â° to +45Â°C operating range, ETS-configurable backlight LED.",
                img: "./images/hexaseries/38.png",
                features: ["KNX BUS protocol", "CNC metal build", "21â€“30 VDC input", "Max 90% humidity", "86Ã—86Ã—24 mm size", "â€“5Â° to +45Â°C operating range", "ETS-configurable backlight LED"]
            },
            "MULTI SOCKET + 2 USB": {
                title: "MULTI SOCKET + 2 USB",
                desc: "CNC metal body, 230V AC input, max 90% humidity, 86Ã—86Ã—24 mm size, â€“5Â° to +45Â°C operating temperature.",
                img: "./images/hexaseries/39.png",
                features: ["CNC metal body", "230V AC input", "Max 90% humidity", "86Ã—86Ã—24 mm size", "â€“5Â° to +45Â°C operating temperature"]
            },
            "DND SWITCH": {
                title: "DND SWITCH",
                desc: "CNC metal, 230V AC, max 90% humidity, 86Ã—86Ã—24 mm, â€“5Â° to +45Â°C, features: Calling Bell, DND, Clean Room, Wait.",
                img: "./images/hexaseries/40.png",
                features: ["CNC metal", "230V AC", "Max 90% humidity", "86Ã—86Ã—24 mm", "â€“5Â° to +45Â°C", "Calling Bell", "DND", "Clean Room", "Wait"]
            },
            "RFIC CARD READER": {
                title: "RFIC CARD READER",
                desc: "CNC metal, 230V AC, max 90% humidity, 86Ã—86Ã—24 mm, â€“5Â° to +45Â°C, supports 13.56 MHz IC cards.",
                img: "./images/hexaseries/41.png",
                features: ["CNC metal", "230V AC", "Max 90% humidity", "86Ã—86Ã—24 mm", "â€“5Â° to +45Â°C", "Supports 13.56 MHz IC cards"]
            },
            "THERMOSTAT": {
                title: "THERMOSTAT",
                desc: "KNX protocol, aluminium CNC finish, 21â€“30 VDC, max 90% humidity, 86Ã—86Ã—24 mm, â€“5Â° to 45Â°C operating range.",
                img: "./images/hexaseries/42.png",
                features: ["KNX protocol", "Aluminium CNC finish", "21â€“30 VDC", "Max 90% humidity", "86Ã—86Ã—24 mm", "â€“5Â° to 45Â°C operating range"]
            }
        }
    },
    "DUO-QUAD SERIES": {
        title: "Duo-Quad Series",
        desc: "Advanced KNX control devices.",
        subProducts: {
            "8 BUTTON KNX SWITCH": {
                title: "8 BUTTON KNX SWITCH",
                desc: "KNX BUS device, CNC metal body, 21â€“30 VDC, max 90% humidity, 86Ã—86Ã—24 mm, â€“5Â° to +45Â°C operating range.",
                img: "./images/duoquad/43.png",
                features: ["KNX BUS device", "CNC metal body", "21â€“30 VDC", "Max 90% humidity", "86Ã—86Ã—24 mm", "â€“5Â° to +45Â°C operating range"]
            },
            "8 BUTTON KNX SWITCH WITH 4 GANG RELAY": {
                title: "8 BUTTON KNX SWITCH WITH 4 GANG RELAY",
                desc: "KNX BUS 4Ã—16A output module CNC metal, 21â€“30 VDC, max 90% humidity, 86Ã—86Ã—24 mm, â€“5Â° to +45Â°C operating range.",
                img: "./images/duoquad/44.png",
                features: ["KNX BUS 4Ã—16A output module", "CNC metal", "21â€“30 VDC", "Max 90% humidity", "86Ã—86Ã—24 mm", "â€“5Â° to +45Â°C operating range"]
            },
            "THERMOSTAT": {
                title: "THERMOSTAT",
                desc: "KNX device â€“ aluminium CNC finish, 21â€“30 VDC, max 90% humidity, 86Ã—86Ã—24 mm, â€“5Â° to 45Â°C operating range.",
                img: "./images/duoquad/45.png",
                features: ["KNX device", "Aluminium CNC finish", "21â€“30 VDC", "Max 90% humidity", "86Ã—86Ã—24 mm", "â€“5Â° to 45Â°C operating range"]
            },
            "SOCKET": {
                title: "SOCKET",
                desc: "KNX protocol, aluminium CNC finish, 21â€“30 VDC, max 90% humidity, 86Ã—86Ã—24 mm, â€“5Â° to 45Â°C operating range.",
                img: "./images/duoquad/46.png",
                features: ["KNX protocol", "Aluminium CNC finish", "21â€“30 VDC", "Max 90% humidity", "86Ã—86Ã—24 mm", "â€“5Â° to 45Â°C operating range"]
            }
        }
    },
    "DOMOGENIE GLASS LITE SERIES": {
        title: "Domogenie Glass Lite Series",
        desc: "Tempered glass switch modules with RGB backlight.",
        subProducts: {
            "2 MODULE": {
                title: "2 MODULE",
                desc: "86Ã—86Ã—35.7 mm, 230V AC (N+L), 100W fan/dimmer, 30A relay, WiFi/ZigBee, tempered glass + aluminium frame, RGB backlight, black/white/custom options.",
                img: "./images/domoglass/31.png",
                features: ["86Ã—86Ã—35.7 mm", "230V AC (N+L)", "100W fan/dimmer", "30A relay", "WiFi/ZigBee", "Tempered glass + aluminium frame", "RGB backlight", "Black/white/custom options"]
            },
            "4 MODULE": {
                title: "4 MODULE",
                desc: "450Ã—86Ã—38.9 mm, tempered glass + aluminium frame, supports cast options.",
                img: "./images/domoglass/32.png",
                features: ["450Ã—86Ã—38.9 mm", "230V AC (N+L)", "100W fan/dimmer", "30A relay", "WiFi/ZigBee", "Tempered glass + aluminium frame", "RGB backlight", "Black/white/custom glass w/ black/silver/gold frame"]
            },
            "6 MODULE": {
                title: "6 MODULE",
                desc: "234Ã—86Ã—37.2 mm tempered glass panel.",
                img: "./images/domoglass/33.png",
                features: ["234Ã—86Ã—37.2 mm", "230V AC (N+L)", "100W fan/dimmer", "30A relay", "WiFi/ZigBee", "Tempered glass + aluminium frame", "RGB backlight", "Black/white/custom glass w/ black/silver/gold frame"]
            },
            "8 MODULE": {
                title: "8 MODULE",
                desc: "253Ã—86Ã—38.2 mm panel for premium installs.",
                img: "./images/domoglass/34.png",
                features: ["253Ã—86Ã—38.2 mm", "230V AC (N+L)", "100W fan/dimmer", "30A relay", "WiFi/ZigBee", "Tempered glass + aluminium frame", "RGB backlight", "Black/white/custom glass w/ black/silver/gold frame"]
            },
            "12 MODULE": {
                title: "12 MODULE",
                desc: "237Ã—152Ã—37.2 mm, multi-module panel.",
                img: "./images/domoglass/35.png",
                features: ["237Ã—152Ã—37.2 mm", "230V AC (N+L)", "100W fan/dimmer", "30A relay", "WiFi/ZigBee", "Tempered glass + aluminium frame", "RGB backlight", "Black/white/custom glass w/ black/silver/gold frame"]
            }
        }
    },
    "TREMBLAY SOUNDS": {
        title: "Tremblay Sounds",
        desc: "Premium audio solutions.",
        subProducts: {
            "MULTIROOM AUDIO CEILING SPEAKER": {
                title: "Multiroom Audio Ceiling Speaker",
                desc: "In-ceiling streaming speaker with built-in amplifier.",
                img: "./images/tremblay/53.png",
                features: ["Built-in amplifier", "Wi-Fi/Bluetooth/Ethernet", "50WÃ—2 output", "6.5\" glass-fibre woofer + 1\" aluminium tweeter", "40â€“20kHz response", "Supports AirPlay/DLNA/Spotify Connect"]
            }
        }
    },
    "Z-WAVE RELAY": {
        title: "Z-Wave Relay",
        desc: "Multi-channel relay modules and accessories.",
        relay: true,
        img: "./images/relay/47.png"
    },
    "CURTAIN MOTORS": {
        title: "Curtain Motors",
        desc: "Smart curtain motor systems.",
        subProducts: {
            "N+ KNX SERIES CURTAIN MOTOR": {
                title: "N+ KNX SERIES CURTAIN MOTOR",
                desc: "Dual KNX + 433MHz control, real-time feedback, works with all KNX devices, KNX 21â€“30VDC & 100â€“240V AC motor, 1.5 NÂ·m torque, 50kg load, 13cm/s speed, 0.9â€“12m width, >4min runtime, <28dB noise, IP20, â€“10Â°C to +55Â°C.",
                img: "./images/curtain/51.png",
                features: ["Dual KNX + 433MHz control", "Real-time feedback", "Works with all KNX devices", "KNX 21â€“30VDC & 100â€“240V AC motor", "1.5 NÂ·m torque", "50kg load", "13cm/s speed", "0.9â€“12m width", ">4min runtime", "<28dB noise", "IP20", "â€“10Â°C to +55Â°C"]
            },
            "LUMI N+ 5 WIRE MOTOR": {
                title: "LUMI N+ 5 WIRE MOTOR",
                desc: "Dual KNX + RF control, real-time feedback, fully KNX compatible, KNX 21â€“30VDC & 100â€“240V AC motor, 1.5 NÂ·m torque, 50kg load, 13cm/s speed, 0.9â€“12m width, >4min runtime, <28dB noise, IP20, â€“10Â°C to +55Â°C.",
                img: "./images/curtain/52.png",
                features: ["Dual KNX + RF control", "Real-time feedback", "Fully KNX compatible", "KNX 21â€“30VDC & 100â€“240V AC motor", "1.5 NÂ·m torque", "50kg load", "13cm/s speed", "0.9â€“12m width", ">4min runtime", "<28dB noise", "IP20", "â€“10Â°C to +55Â°C"]
            }
        }
    },
    "SENSORS": {
        title: "Sensors",
        desc: "Advanced detection and monitoring sensors for smart homes.",
        subProducts: {
            "FALL DETECTION SENSOR": {
                title: "Fall Detection Sensor",
                desc: "Advanced AI-powered fall detection sensor with emergency alert system.",
                img: "./images/sensors/56.png",
                features: ["AI-powered fall detection", "Emergency alert system", "24/7 monitoring", "Wi-Fi/Bluetooth connectivity", "Long battery life", "Water-resistant design"]
            },
            "HUMAN PRESENCE SENSOR": {
                title: "Human Presence Sensor",
                desc: "Microwave-based presence detection with high accuracy and wide coverage.",
                img: "./images/sensors/55.png",
                features: ["Microwave detection technology", "360Â° coverage", "Adjustable sensitivity", "Built-in temperature sensor", "Energy saving mode", "Easy installation"]
            },
            "OCCUPANCY SENSOR": {
                title: "Occupancy Sensor",
                desc: "Motion-based occupancy detection for lighting and HVAC control.",
                img: "./images/sensors/54.png",
                features: ["PIR motion detection", "Time-delay adjustment", "Lux level sensing", "Dual-technology option", "Ceiling/wall mount", "Energy compliance certified"]
            }
        }
    },
    "AUTOMATION DISTRIBUTION BOX": {
        title: "Automation Distribution Box",
        desc: "Professional distribution boxes for automation system components.",
        isDBBox: true,
        brand: "",
        size: "",
        img: "./images/db/1.png",
        features: ["Modular design", "DIN rail mounting", "Transparent cover", "IP65 rated", "Wall mountable", "Cable management"]
    },
    "NETWORK DISTRIBUTION BOX": {
        title: "Network Distribution Box",
        desc: "Distribution boxes for network and communication equipment.",
        isDBBox: true,
        brand: "",
        size: "",
        img: "./images/db/1.png",
        features: ["Cable management", "Ventilation slots", "Wall mountable", "Lockable door", "Rack mount options"]
    }
};

const PRODUCT_ORDER = [
    "DOOR LOCK",
    "PROCESSOR",
    "LUMI GLASS SERIES",
    "ESCULT SERIES",
    "TACTILE HEXA SERIES",
    "DUO-QUAD SERIES",
    "DOMOGENIE GLASS LITE SERIES",
    "WALL MOUNT DISPLAY",
    "TREMBLAY SOUNDS",
    "Z-WAVE RELAY",
    "CURTAIN MOTORS",
    "SENSORS",
    "AUTOMATION DISTRIBUTION BOX",
    "NETWORK DISTRIBUTION BOX"
];

/* ------------------------- UI BUILD ------------------------- */
const productListEl = document.getElementById('productList');
const pTitle = document.getElementById('pTitle');
const pDesc = document.getElementById('pDesc');
const pMeta = document.getElementById('pMeta');
const pFeatures = document.getElementById('pFeatures');
const featuresSection = document.getElementById('featuresSection');
const productImage = document.getElementById('productImage');
const productImageOverlay = document.getElementById('productImageOverlay');
const previewImage = document.getElementById('previewImage');
const imgInner = document.getElementById('imgInner');
const imgContainer = document.getElementById('imgContainer');
const relayControlsEl = document.getElementById('relayControls');
const relayOptionsList = document.getElementById('relayOptionsList');
const productModalEl = document.getElementById('productModal');
const modalProductTitle = document.getElementById('modalProductTitle');
const modalProductDesc = document.getElementById('modalProductDesc');
const modalProductImage = document.getElementById('modalProductImage');
const modalProductFeatures = document.getElementById('modalProductFeatures');
const modalCloseBtn = document.getElementById('modalCloseBtn');

const relayOptions = [
    { id: 'relay-1ch', label: '1 Channel Relay' },
    { id: 'relay-2ch', label: '2 Channel Relay' },
    { id: 'relay-curtain', label: '1 Channel Curtain Relay' },
    { id: 'relay-dimmer', label: '0-10V Analog Dimmer' },
    { id: 'relay-remote', label: 'LS Series Remote' }
];

const relayOptionImages = {
    'relay-1ch': './images/relay/48.png',
    'relay-2ch': './images/relay/49.png',
    'relay-curtain': './images/relay/47.png',
    'relay-dimmer': './images/relay/50.png',
    'relay-remote': './images/relay/48.png'
};

const relayState = relayOptions.reduce((acc, opt) => {
    acc[opt.id] = { selected: false, quantity: 1 };
    return acc;
}, {});
let lastRelaySelectionLabel = '';

function relaySelectionsFromState() {
    return relayOptions
        .filter(opt => relayState[opt.id].selected)
        .map(opt => ({ name: opt.label, quantity: relayState[opt.id].quantity, id: opt.id }));
}

function updateRelayOverlay() {
    if (currentProduct !== 'Z-WAVE RELAY') {
        productImageOverlay.style.display = 'none';
        productImageOverlay.textContent = '';
        return;
    }
    const selections = relaySelectionsFromState();
    productImageOverlay.style.display = 'block';
    if (selections.length === 0) {
        productImageOverlay.textContent = 'Select relay modules to highlight them.';
        resetRelayPreview();
        return;
    }
    const preferred = selections.find(sel => sel.name === lastRelaySelectionLabel) || selections[selections.length - 1];
    productImageOverlay.innerHTML = `<strong>${preferred.name}</strong><br>Qty ${preferred.quantity}`;
    setRelayPreview(preferred.id);
}

function setRelayPreview(optionId) {
    const baseImg = productData['Z-WAVE RELAY']?.img || '';
    const src = relayOptionImages[optionId] || baseImg;
    if (currentProduct === 'Z-WAVE RELAY' && src) {
        productImage.src = src;
    }
}

function resetRelayPreview() {
    const baseImg = productData['Z-WAVE RELAY']?.img || '';
    if (currentProduct === 'Z-WAVE RELAY' && baseImg) {
        productImage.src = baseImg;
    }
}

const switchFamilies = new Set([
    "LUMI GLASS SERIES",
    "ESCULT SERIES",
    "TACTILE HEXA SERIES",
    "DUO-QUAD SERIES",
    "DOMOGENIE GLASS LITE SERIES"
]);

const seriesCounters = {};

function getSeriesCode(productKey) {
    if (productKey === 'DOOR LOCK') return 'L';
    if (productKey === 'PROCESSOR') return 'P';
    if (productKey === 'WALL MOUNT DISPLAY') return 'D';
    if (productKey === 'CURTAIN MOTORS') return 'C';
    if (productKey === 'Z-WAVE RELAY') return 'R';
    if (productKey === 'TREMBLAY SOUNDS') return 'T';
    if (productKey === 'AUTOMATION DISTRIBUTION BOX') return 'ADB';
    if (productKey === 'NETWORK DISTRIBUTION BOX') return 'NDB';
    if (switchFamilies.has(productKey)) return 'S';
    return 'S';
}

/* ------------------------- LOAD FLOOR PLAN IMAGE ------------------------- */
function loadFloorPlanImage() {
    const previewImage = document.getElementById('previewImage');

    const uploadedFloorPlan = sessionStorage.getItem('uploadedFloorPlan');
    const exportedPlan = sessionStorage.getItem('exportedPlan');

    previewImage.src = '';

    // Add a loading placeholder to maintain aspect ratio
    previewImage.style.visibility = 'hidden';

    if (uploadedFloorPlan) {
        console.log('ðŸ“¤ Loading uploaded floor plan from index.html');
        previewImage.src = uploadedFloorPlan;
        sessionStorage.removeItem('uploadedFloorPlan');
    } else if (exportedPlan) {
        console.log('ðŸ  Loading exported floor plan from floor planner');
        previewImage.src = exportedPlan;
    } else {
        console.log('ðŸ¢ Using default floor plan image');
        previewImage.src = 'https://virtualtourslasvegas.com/wp-content/uploads/2023/01/1701-N-Green-Valley-Pkwy-8A.jpg';
    }

    previewImage.onload = function () {
        console.log('âœ… Floor plan image loaded successfully');
        // Make image visible
        previewImage.style.visibility = 'visible';

        // Force a reflow to ensure dimensions are accurate
        void previewImage.offsetWidth;

        // Wait a frame for layout to settle
        setTimeout(() => {
            updateImageDimensions();
            clearAllMarksAndWires();
        }, 50);
    };

    previewImage.onerror = function () {
        console.error('âŒ Failed to load floor plan image');
        previewImage.style.visibility = 'visible';
        const exportedFallback = sessionStorage.getItem('exportedPlan');
        if (exportedFallback && previewImage.src !== exportedFallback) {
            console.log('ðŸ”„ Trying exported plan as fallback');
            previewImage.src = exportedFallback;
            return;
        }
        console.log('ðŸ”„ Using default image as fallback');
        previewImage.src = 'https://virtualtourslasvegas.com/wp-content/uploads/2023/01/1701-N-Green-Valley-Pkwy-8A.jpg';
    };
}

function clearAllMarksAndWires() {
    marks.forEach(mark => {
        if (mark.el && mark.el.parentNode) {
            mark.el.parentNode.removeChild(mark.el);
        }
    });
    marks.length = 0;

    wires.forEach(wire => {
        if (wire.element && wire.element.svg) {
            wire.element.svg.remove();
        }
    });
    wires.length = 0;

    markCounter = 0;
    selectedMarkId = null;

    isWireMode = false;
    currentWireType = null;
    wireStartMark = null;
    wireEndMark = null;
    selectedWire = null;
    wirePoints = [];

    renderMarksList();
    updateWiresList();
    hideWireControls();

    console.log('ðŸ§¹ Cleared all marks and wires for new image');
}

function nextSeriesLabel(productKey) {
    const code = getSeriesCode(productKey);

    const existingMarks = marks.filter(mark => mark.seriesCode === code);

    if (existingMarks.length > 0) {
        const existingNumbers = existingMarks.map(mark => {
            const num = parseInt(mark.seriesLabel.substring(1));
            return isNaN(num) ? 0 : num;
        });

        let nextNum = 1;
        while (existingNumbers.includes(nextNum)) {
            nextNum++;
        }

        seriesCounters[code] = nextNum;
        return { seriesCode: code, label: `${code}${nextNum}` };
    } else {
        seriesCounters[code] = 1;
        return { seriesCode: code, label: `${code}1` };
    }
}

let currentProduct = null;
let currentSubProduct = null;
let imageScale = 1;
const marks = [];
let selectedMarkId = null;
let imageNaturalWidth = 0;
let imageNaturalHeight = 0;
let imageDisplayWidth = 0;
let imageDisplayHeight = 0;

const wires = [];
let isWireMode = false;
let currentWireType = null;
let currentWireMode = 'curve';
let wireStartMark = null;
let wireEndMark = null;
let selectedWire = null;
let wirePoints = [];

const wireTypes = [
    {
        id: 'knx',
        name: 'KNX_WIRE',
        title: 'KNX Bus Wire',
        color: '#4CAF50',
        icon: 'electric_bolt',
        bgColor: '#f0f9f0',
        borderColor: '#c8e6c9'
    },
    {
        id: 'phase',
        name: 'PHASE_WIRE',
        title: 'Phase Wire (Live)',
        color: '#f44336',
        icon: 'flash_on',
        bgColor: '#ffebee',
        borderColor: '#ffcdd2'
    },
    {
        id: 'neutral',
        name: 'NEUTRAL_WIRE',
        title: 'Neutral Wire',
        color: '#000000',
        icon: 'power',
        bgColor: '#f5f5f5',
        borderColor: '#e0e0e0'
    }
];

/* ------------------------- DB BOX FUNCTIONS ------------------------- */
function createDBBoxControls() {
    const existingControls = document.getElementById('dbControls');
    if (existingControls) {
        existingControls.remove();
    }

    const data = productData[currentProduct];
    if (!data || !data.isDBBox) return;

    const dbControlsHTML = `
            <div class="mark-controls-box" id="dbControls" style="margin-top: 20px; border-color: #2196F3;">
                <h3 style="color: #2196F3; margin-bottom: 15px;">
                    <span class="material-icons" style="font-size: 18px; vertical-align: middle; margin-right: 8px;">settings</span>
                    DB Box Specifications
                </h3>
                
                <div class="form-group">
                    <label style="color: #2196F3; font-weight: 500;">Brand</label>
                    <input type="text" 
                           id="dbBrandInput" 
                           class="form-control" 
                           placeholder="Enter brand name (e.g., Legrand, Schneider)"
                           value="${data.brand || ''}"
                           style="border-color: #2196F3;">
                    <div style="font-size: 11px; color: #666; margin-top: 4px;">
                        <span class="material-icons" style="font-size: 11px; vertical-align: middle;">info</span>
                        Enter the manufacturer brand
                    </div>
                </div>

                <div class="form-group" style="margin-top: 15px;">
                    <label style="color: #2196F3; font-weight: 500;">Size (in feet)</label>
                    <input type="text" 
                           id="dbSizeInput" 
                           class="form-control" 
                           placeholder="Enter size in feet (e.g., 2x3, 4x6)"
                           value="${data.size || ''}"
                           style="border-color: #2196F3;">
                    <div style="font-size: 11px; color: #666; margin-top: 4px;">
                        <span class="material-icons" style="font-size: 11px; vertical-align: middle;">info</span>
                        Enter dimensions like 2x3, 4x6, etc.
                    </div>
                </div>

                <div class="form-group" style="margin-top: 20px;">
                    <button id="saveDBSpecsBtn" class="btn primary full-width" style="background: #2196F3; border-color: #2196F3;">
                        <span class="material-icons" style="font-size: 16px; margin-right: 8px;">save</span>
                        Save Specifications
                    </button>
                </div>

                <div style="margin-top: 15px; padding: 12px; background: #f0f7ff; border-radius: 6px; border: 1px solid #bbdefb;">
                    <div style="font-size: 12px; color: #2196F3; margin-bottom: 4px;">
                        <span class="material-icons" style="font-size: 14px; vertical-align: middle; margin-right: 4px;">info</span>
                        Specifications Info
                    </div>
                    <div style="font-size: 11px; color: #555;">
                        â€¢ Brand and size will be displayed in PDF<br>
                        â€¢ Size will be shown in model name when label is clicked<br>
                        â€¢ Information is saved per DB box type
                    </div>
                </div>
            </div>
        `;

    const markControlsBox = document.querySelector('.mark-controls-box');
    if (markControlsBox) {
        markControlsBox.insertAdjacentHTML('afterend', dbControlsHTML);
        attachDBControlsEvents();
    }
}

function attachDBControlsEvents() {
    const saveBtn = document.getElementById('saveDBSpecsBtn');
    const brandInput = document.getElementById('dbBrandInput');
    const sizeInput = document.getElementById('dbSizeInput');

    if (saveBtn && brandInput && sizeInput) {
        saveBtn.addEventListener('click', function () {
            const brand = brandInput.value.trim();
            const size = sizeInput.value.trim();

            if (!brand || !size) {
                showNotification('Please enter both brand and size', 'error');
                return;
            }

            if (productData[currentProduct]) {
                productData[currentProduct].brand = brand;
                productData[currentProduct].size = size;

                marks.forEach(mark => {
                    if (mark.categoryName === currentProduct) {
                        mark.modelName = `${brand} - ${size} ft`;
                        mark.desc = `${currentProduct}: ${brand} ${size} ft`;
                        mark.brand = brand;
                        mark.sizeFt = size;
                    }
                });

                showNotification('DB Box specifications saved successfully!', 'success');
                renderMarksList();
            }
        });
    }
}

function orientTooltip(mark) {
    const tooltip = mark?.tooltip;
    if (!tooltip || !imageNaturalWidth || !imageNaturalHeight) return;
    const offset = 12;
    const centerX = mark.x + (mark.size / 2);
    const centerY = mark.y + (mark.size / 2);
    const verticalIsBottom = centerY < (imageNaturalHeight / 2);
    const horizontalIsRight = centerX < (imageNaturalWidth / 2);

    tooltip.dataset.vertical = verticalIsBottom ? 'bottom' : 'top';
    tooltip.dataset.horizontal = horizontalIsRight ? 'right' : 'left';

    if (verticalIsBottom) {
        tooltip.style.top = '100%';
    } else {
        tooltip.style.top = '0';
    }

    if (horizontalIsRight) {
        tooltip.style.left = '100%';
    } else {
        tooltip.style.left = '0';
    }

    const translateX = horizontalIsRight ? `${offset}px` : `calc(-100% - ${offset}px)`;
    const translateY = verticalIsBottom ? `${offset}px` : `calc(-100% - ${offset}px)`;
    tooltip.style.transform = `translate(${translateX}, ${translateY})`;
}

function populateModal(mark) {
    if (!mark) return;

    let title = '';
    if (mark.isDBBox && mark.sizeFt) {
        title = `${mark.categoryName || ''} â€” ${mark.brand || ''} ${mark.sizeFt} ft`.trim() || 'DB Box';
    } else {
        title = `${mark.categoryName || ''}${mark.modelName ? ' â€” ' + mark.modelName : ''}`.trim() || 'Product';
    }

    modalProductTitle.textContent = title;

    let description = mark.desc || '';
    if (mark.isDBBox) {
        description = `${mark.categoryName || 'DB Box'}\nBrand: ${mark.brand || 'Not specified'}\nSize: ${mark.sizeFt || 'Not specified'} feet`;
    }

    modalProductDesc.textContent = description;
    const imageSrc = mark.imageSrc || previewImage.src;
    if (imageSrc) {
        modalProductImage.src = imageSrc;
        modalProductImage.style.display = 'block';
    } else {
        modalProductImage.style.display = 'none';
    }
    modalProductFeatures.innerHTML = '';
    const featureList = (mark.features && mark.features.length ? mark.features : ['No features provided']).slice(0, 12);
    featureList.forEach(feature => {
        const li = document.createElement('li');
        li.textContent = feature;
        modalProductFeatures.appendChild(li);
    });
}

function openProductModal(mark) {
    populateModal(mark);
    productModalEl.classList.add('show');
}

function closeProductModal() {
    productModalEl.classList.remove('show');
}

modalCloseBtn.addEventListener('click', closeProductModal);
productModalEl.addEventListener('click', (e) => {
    if (e.target === productModalEl) {
        closeProductModal();
    }
});

function buildList() {
    productListEl.innerHTML = '';

    wireTypes.forEach(wireType => {
        const wireItem = document.createElement('div');
        wireItem.className = 'tab-btn';
        wireItem.dataset.name = wireType.name;
        wireItem.dataset.wireType = wireType.id;
        wireItem.innerHTML = `
                <div class="tab-title" style="color: ${wireType.color}; font-weight: 600;">
                    <span class="material-icons" style="font-size: 18px; margin-right: 8px; vertical-align: middle;">${wireType.icon}</span>
                    ${wireType.title}
                </div>
                <div class="tab-sub">
                    <span class="material-icons" style="font-size:20px;color:${wireType.color}">add_link</span>
                </div>
            `;
        wireItem.addEventListener('click', () => {
            currentWireType = wireType.id;
            isWireMode = true;

            document.querySelectorAll('.tab-btn[data-name^="KNX_WIRE"], .tab-btn[data-name^="PHASE_WIRE"], .tab-btn[data-name^="NEUTRAL_WIRE"]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.name === wireType.name);
            });

            showWireControls();
            showNotification(`${wireType.title} Mode: Select two marks to connect them`, 'info');
        });
        productListEl.appendChild(wireItem);
    });

    const separator = document.createElement('div');
    separator.style.height = '1px';
    separator.style.backgroundColor = 'var(--border)';
    separator.style.margin = '15px 0';
    productListEl.appendChild(separator);

    const keys = PRODUCT_ORDER.length ? PRODUCT_ORDER.filter(k => productData[k]) : Object.keys(productData);
    for (const key of keys) {
        const item = document.createElement('div');
        item.className = 'tab-btn';
        item.dataset.name = key;

        const left = document.createElement('div');
        left.className = 'tab-title';
        left.textContent = key;

        const right = document.createElement('div');
        right.className = 'tab-sub';

        if (productData[key].subProducts && !productData[key].isDBBox) {
            right.innerHTML = '<span class="material-icons" style="font-size:20px;color:var(--muted)">expand_more</span>';
            item.addEventListener('click', (e) => {
                e.stopPropagation();
                const existing = item.nextElementSibling;
                if (existing && existing.classList.contains('sub-product-list')) {
                    existing.remove();
                    item.querySelector('.material-icons').textContent = 'expand_more';
                } else {
                    createSubProducts(item, key);
                    item.querySelector('.material-icons').textContent = 'expand_less';
                }
            });
        } else {
            item.addEventListener('click', () => selectProduct(key));
        }

        item.appendChild(left);
        item.appendChild(right);
        productListEl.appendChild(item);
    }
}

function createSubProducts(afterItem, productKey) {
    const wrap = document.createElement('div');
    wrap.className = 'sub-product-list';
    wrap.style.marginTop = '8px';
    wrap.style.marginBottom = '8px';
    wrap.style.paddingLeft = '8px';
    wrap.style.borderLeft = '2px solid var(--border)';

    const subProducts = productData[productKey].subProducts;
    for (const subKey of Object.keys(subProducts)) {
        const btn = document.createElement('div');
        btn.className = 'tab-btn';
        btn.style.background = '#f8f9fa';
        btn.style.border = '1px solid var(--border)';
        btn.dataset.name = productKey + '|' + subKey;
        btn.innerHTML = `<div class="tab-title">${subKey}</div>`;
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            selectProduct(productKey, subKey);
        });
        wrap.appendChild(btn);
    }
    afterItem.parentNode.insertBefore(wrap, afterItem.nextSibling);
}

function buildRelayOptions() {
    relayOptionsList.innerHTML = '';
    relayOptions.forEach(option => {
        const row = document.createElement('div');
        row.className = 'relay-option';
        row.dataset.optionId = option.id;
        const label = document.createElement('label');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = relayState[option.id].selected;
        checkbox.addEventListener('change', () => {
            relayState[option.id].selected = checkbox.checked;
            if (checkbox.checked) {
                lastRelaySelectionLabel = option.label;
            } else {
                if (lastRelaySelectionLabel === option.label) {
                    lastRelaySelectionLabel = '';
                }
            }
            updateRelayOverlay();
        });
        label.appendChild(checkbox);
        const span = document.createElement('span');
        span.textContent = option.label;
        label.appendChild(span);
        const qty = document.createElement('input');
        qty.type = 'number';
        qty.min = 1;
        qty.value = relayState[option.id].quantity;
        qty.addEventListener('input', () => {
            const val = Math.max(1, parseInt(qty.value || '1', 10));
            qty.value = val;
            relayState[option.id].quantity = val;
            if (checkbox.checked) {
                updateRelayOverlay();
            }
        });
        row.appendChild(label);
        const qtyWrap = document.createElement('div');
        qtyWrap.className = 'relay-qty-row';
        const qtyLabel = document.createElement('span');
        qtyLabel.textContent = 'Quantity';
        qtyWrap.appendChild(qtyLabel);
        qtyWrap.appendChild(qty);
        row.appendChild(qtyWrap);
        relayOptionsList.appendChild(row);
    });
    updateRelayOverlay();
}

function getSelectedRelayItems() {
    return relaySelectionsFromState();
}

function selectProduct(productKey, subProductKey = null) {
    currentProduct = productKey;
    currentSubProduct = subProductKey;

    document.querySelectorAll('.tab-btn').forEach(b => {
        const isActive = (b.dataset.name === productKey) ||
            (subProductKey && b.dataset.name === (productKey + '|' + subProductKey));
        b.classList.toggle('active', isActive);
    });

    let data = productData[productKey];
    let title = data.title || productKey;
    let desc = data.desc || '';
    let img = '';
    let features = [];
    const isRelay = productKey === 'Z-WAVE RELAY';
    const isDBBox = data.isDBBox || false;

    if (isDBBox) {
        title = data.title;
        desc = data.desc;
        img = data.img || '';
        features = data.features || [];
        currentSubProduct = null;
    } else if (subProductKey && data.subProducts && data.subProducts[subProductKey]) {
        const subData = data.subProducts[subProductKey];
        title = subData.title;
        desc = subData.desc;
        img = subData.img;
        features = subData.features || [];
    } else if (data.subProducts) {
        title = data.title;
        desc = data.desc;
        img = '';
        features = [];
    }

    pTitle.textContent = title;
    pDesc.textContent = desc;

    const resolvedImg = img || data.img || '';
    if (resolvedImg) {
        productImage.src = resolvedImg;
        productImage.style.display = 'block';
    } else {
        productImage.style.display = 'none';
    }

    pMeta.innerHTML = '';
    if (subProductKey && !isDBBox) {
        const meta = document.createElement('div');
        meta.className = 'meta-item';
        meta.textContent = subProductKey;
        pMeta.appendChild(meta);
    }

    if (isRelay) {
        featuresSection.style.display = 'none';
        relayControlsEl.style.display = 'block';
        buildRelayOptions();
        productImageOverlay.style.display = 'block';
        updateRelayOverlay();
        document.getElementById('dbControls') && (document.getElementById('dbControls').style.display = 'none');

    } else if (isDBBox) {
        relayControlsEl.style.display = 'none';
        featuresSection.style.display = 'block';
        productImageOverlay.style.display = 'none';
        productImageOverlay.textContent = '';
        resetRelayPreview();
        lastRelaySelectionLabel = '';

        createDBBoxControls();

        pFeatures.innerHTML = '';
        if (features.length > 0) {
            features.forEach(feature => {
                const li = document.createElement('li');
                li.textContent = feature;
                pFeatures.appendChild(li);
            });
        }
    } else {
        relayControlsEl.style.display = 'none';
        featuresSection.style.display = 'block';
        productImageOverlay.style.display = 'none';
        productImageOverlay.textContent = '';
        resetRelayPreview();
        lastRelaySelectionLabel = '';

        document.getElementById('dbControls') && (document.getElementById('dbControls').style.display = 'none');


        pFeatures.innerHTML = '';
        if (features.length > 0) {
            features.forEach(feature => {
                const li = document.createElement('li');
                li.textContent = feature;
                pFeatures.appendChild(li);
            });
        } else {
            const li = document.createElement('li');
            li.textContent = 'Select a sub-product to see features';
            pFeatures.appendChild(li);
        }
    }
}

/* ------------------------- WIRE MAPPING FUNCTIONS ------------------------- */
function getWireTypeInfo(type) {
    return wireTypes.find(wt => wt.id === type) || wireTypes[0];
}

function showWireControls() {
    const wireTypeInfo = getWireTypeInfo(currentWireType);

    hideWireControls();

    const wireControlsHTML = `
            <div class="mark-controls-box" id="wireControls" style="margin-top: 20px; border-color: ${wireTypeInfo.color};">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="color: ${wireTypeInfo.color}; margin: 0;">
                        <span class="material-icons" style="font-size: 18px; vertical-align: middle; margin-right: 8px;">${wireTypeInfo.icon}</span>
                        ${wireTypeInfo.title} Mapping
                    </h3>
                    <button id="clearWireSelectionBtn" class="btn" style="padding: 4px 8px; font-size: 11px; background: #f8f9fa; border-color: #ccc;">
                        <span class="material-icons" style="font-size: 14px; margin-right: 4px;">clear</span>
                        Clear
                    </button>
                </div>
                
                <div class="form-group">
                    <div style="background: ${wireTypeInfo.bgColor}; padding: 12px; border-radius: 8px; margin-bottom: 16px; border: 1px solid ${wireTypeInfo.borderColor};">
                        <div style="font-size: 12px; color: ${wireTypeInfo.color}; margin-bottom: 8px;">
                            <span class="material-icons" style="font-size: 14px; vertical-align: middle; margin-right: 4px;">info</span>
                            Select two marks to connect them with a ${wireTypeInfo.title.toLowerCase()}
                        </div>
                        <div style="font-size: 11px; color: #555; display: flex; align-items: center; gap: 12px;">
                            <span id="wireStartLabel">Start: <strong>None</strong></span>
                            <span class="material-icons" style="font-size: 16px; color: ${wireTypeInfo.color};">arrow_forward</span>
                            <span id="wireEndLabel">End: <strong>None</strong></span>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label style="color: ${wireTypeInfo.color};">Wire Mode</label>
                    <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                        <button id="curveModeBtn" class="btn" style="flex: 1; border-color: ${currentWireMode === 'curve' ? wireTypeInfo.color : '#ccc'}; color: ${currentWireMode === 'curve' ? wireTypeInfo.color : '#666'};">
                            <span class="material-icons" style="font-size: 16px; margin-right: 4px;">timeline</span>
                            Curve Mode
                        </button>
                        <button id="pointsModeBtn" class="btn" style="flex: 1; border-color: ${currentWireMode === 'points' ? wireTypeInfo.color : '#ccc'}; color: ${currentWireMode === 'points' ? wireTypeInfo.color : '#666'};">
                            <span class="material-icons" style="font-size: 16px; margin-right: 4px;">control_point</span>
                            Points Mode
                        </button>
                    </div>
                </div>

                <div id="curveControls" class="form-group" style="${currentWireMode === 'curve' ? '' : 'display: none;'}">
                    <label style="color: ${wireTypeInfo.color};">Wire Curve Level</label>
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 11px; color: #666;">-100</span>
                        <input type="range" id="wireCurveSlider" min="-100" max="100" value="0" style="flex: 1;">
                        <span style="font-size: 11px; color: #666;">100</span>
                        <span id="curveValue" style="font-size: 12px; font-weight: bold; color: ${wireTypeInfo.color}; min-width: 30px; text-align: center;">0</span>
                    </div>
                </div>

                <div id="pointsControls" class="form-group" style="${currentWireMode === 'points' ? '' : 'display: none;'}">
                    <div style="margin-bottom: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-size: 12px; color: ${wireTypeInfo.color};">Control Points (${wirePoints.length})</span>
                            <button id="addPointBtn" class="btn" style="padding: 4px 8px; font-size: 11px;">
                                <span class="material-icons" style="font-size: 14px; margin-right: 2px;">add</span>
                                Add Point
                            </button>
                        </div>
                        <div id="pointsList" style="max-height: 80px; overflow-y: auto; padding: 8px; background: #f8f9fa; border-radius: 6px; border: 1px solid var(--border); font-size: 11px;">
                            <div style="color: var(--muted); text-align: center; padding: 4px;">No points added yet</div>
                        </div>
                    </div>
                    <div style="color: #666; font-size: 10px; padding: 6px; background: #f8f9fa; border-radius: 4px;">
                        <span class="material-icons" style="font-size: 10px; vertical-align: middle; margin-right: 2px;">info</span>
                        Click "Add Point" to add control points â€¢ Points are visible only during creation
                    </div>
                </div>

                <div class="form-group" id="wireActionButtons" style="display: ${wireStartMark && wireEndMark ? 'block' : 'none'};">
                    <button id="createWireBtn" class="btn primary full-width" style="background: ${wireTypeInfo.color}; border-color: ${wireTypeInfo.color};">
                        <span class="material-icons" style="font-size: 16px; margin-right: 8px;">add_link</span>
                        Create ${wireTypeInfo.title}
                    </button>
                    <button id="cancelWireBtn" class="btn full-width" style="margin-top: 8px; border-color: #666; color: #666;">
                        Cancel
                    </button>
                </div>

                <div class="form-group">
                    <label style="color: ${wireTypeInfo.color};">Existing ${wireTypeInfo.title}s</label>
                    <div id="wiresList" style="max-height: 120px; overflow-y: auto; padding: 8px; background: #f8f9fa; border-radius: 8px; border: 1px solid var(--border);">
                        <div style="color: var(--muted); font-size: 12px; text-align: center; padding: 8px;">No ${wireTypeInfo.title.toLowerCase()}s created yet</div>
                    </div>
                </div>

                <div style="margin-top: 12px; color: #666; font-size: 11px; text-align: center; padding: 8px; background: #f8f9fa; border-radius: 6px;">
                    <span class="material-icons" style="font-size: 12px; vertical-align: middle; margin-right: 4px;">tips_and_updates</span>
                    Wire color: ${wireTypeInfo.title} â€¢ Click wire to select â€¢ Drag to move â€¢ Click Clear to reset
                </div>
            </div>
        `;

    const markControlsBox = document.querySelector('.mark-controls-box');
    if (markControlsBox) {
        markControlsBox.insertAdjacentHTML('afterend', wireControlsHTML);
        attachWireControlsEvents();
    }
}

function attachWireControlsEvents() {
    const curveBtn = document.getElementById('curveModeBtn');
    const pointsBtn = document.getElementById('pointsModeBtn');
    const addPointBtn = document.getElementById('addPointBtn');
    const createWireBtn = document.getElementById('createWireBtn');
    const cancelWireBtn = document.getElementById('cancelWireBtn');
    const clearWireSelectionBtn = document.getElementById('clearWireSelectionBtn');

    if (curveBtn) {
        curveBtn.addEventListener('click', () => setWireMode('curve'));
    }

    if (pointsBtn) {
        pointsBtn.addEventListener('click', () => setWireMode('points'));
    }

    if (addPointBtn) {
        addPointBtn.addEventListener('click', addControlPoint);
    }

    if (createWireBtn) {
        createWireBtn.addEventListener('click', createWire);
    }

    if (cancelWireBtn) {
        cancelWireBtn.addEventListener('click', cancelWire);
    }

    if (clearWireSelectionBtn) {
        clearWireSelectionBtn.addEventListener('click', clearWireSelection);
    }

    const wireCurveSlider = document.getElementById('wireCurveSlider');
    if (wireCurveSlider) {
        wireCurveSlider.addEventListener('input', function () {
            const curveValue = document.getElementById('curveValue');
            if (curveValue) {
                curveValue.textContent = this.value;
                updateWirePreview();
            }
        });
    }
}

function hideWireControls() {
    const wireControls = document.getElementById('wireControls');
    if (wireControls) {
        wireControls.remove();
    }
}

function setWireMode(mode) {
    currentWireMode = mode;
    wirePoints = [];

    document.querySelectorAll('.draggable-point').forEach(el => el.remove());

    const curveBtn = document.getElementById('curveModeBtn');
    const pointsBtn = document.getElementById('pointsModeBtn');
    const wireTypeInfo = getWireTypeInfo(currentWireType);

    if (curveBtn) {
        curveBtn.style.borderColor = mode === 'curve' ? wireTypeInfo.color : '#ccc';
        curveBtn.style.color = mode === 'curve' ? wireTypeInfo.color : '#666';
    }
    if (pointsBtn) {
        pointsBtn.style.borderColor = mode === 'points' ? wireTypeInfo.color : '#ccc';
        pointsBtn.style.color = mode === 'points' ? wireTypeInfo.color : '#666';
    }

    const curveControls = document.getElementById('curveControls');
    const pointsControls = document.getElementById('pointsControls');

    if (curveControls) curveControls.style.display = mode === 'curve' ? 'block' : 'none';
    if (pointsControls) pointsControls.style.display = mode === 'points' ? 'block' : 'none';

    const tempWire = document.querySelector('.wire-preview');
    if (tempWire) {
        tempWire.remove();
    }

    if (wireStartMark && wireEndMark) {
        updateWirePreview();
    }

    updatePointsList();
}

function updateWireSelectionLabels() {
    const startLabel = document.getElementById('wireStartLabel');
    const endLabel = document.getElementById('wireEndLabel');

    if (startLabel && endLabel) {
        startLabel.innerHTML = `Start: <strong>${wireStartMark ? wireStartMark.seriesLabel : 'None'}</strong>`;
        endLabel.innerHTML = `End: <strong>${wireEndMark ? wireEndMark.seriesLabel : 'None'}</strong>`;

        const wireActionButtons = document.getElementById('wireActionButtons');

        if (wireStartMark && wireEndMark) {
            if (wireActionButtons) wireActionButtons.style.display = 'block';
            updateWirePreview();
        } else {
            if (wireActionButtons) wireActionButtons.style.display = 'none';
        }
    }
}

function resetWireSelection() {
    wireStartMark = null;
    wireEndMark = null;

    document.querySelectorAll('.draggable-point').forEach(el => el.remove());
    wirePoints = [];

    updateWireSelectionLabels();

    const tempWire = document.querySelector('.wire-preview');
    if (tempWire) {
        tempWire.remove();
    }

    updatePointsList();
}

function addControlPoint() {
    if (!wireStartMark || !wireEndMark) {
        showNotification('Please select start and end marks first', 'error');
        return;
    }

    const transform = getImageTransform();
    if (!transform) return;

    let newX, newY;

    if (wirePoints.length === 0) {
        const startX = wireStartMark.x + (wireStartMark.size / 2);
        const startY = wireStartMark.y + (wireStartMark.size / 2);
        const endX = wireEndMark.x + (wireEndMark.size / 2);
        const endY = wireEndMark.y + (wireEndMark.size / 2);

        newX = (startX + endX) / 2;
        newY = (startY + endY) / 2;
    } else {
        const lastPoint = wirePoints[wirePoints.length - 1];
        const endX = wireEndMark.x + (wireEndMark.size / 2);
        const endY = wireEndMark.y + (wireEndMark.size / 2);

        newX = (lastPoint.x + endX) / 2;
        newY = (lastPoint.y + endY) / 2;
    }

    const point = {
        id: `point-${Date.now()}`,
        x: newX,
        y: newY,
        element: null
    };

    wirePoints.push(point);
    updatePointsList();
    updateWirePreview();

    showNotification(`Point added at position X: ${Math.round(newX)}, Y: ${Math.round(newY)}`, 'info');
}

function updatePointsList() {
    const pointsList = document.getElementById('pointsList');
    if (!pointsList) return;

    pointsList.innerHTML = '';

    if (wirePoints.length === 0) {
        pointsList.innerHTML = '<div style="color: var(--muted); text-align: center; padding: 4px;">No points added yet</div>';
        return;
    }

    wirePoints.forEach((point, index) => {
        const pointItem = document.createElement('div');
        pointItem.className = 'mark-item';
        pointItem.style.marginBottom = '4px';
        pointItem.style.padding = '6px 8px';
        pointItem.style.fontSize = '11px';

        pointItem.innerHTML = `
                <span style="flex: 1;">
                    Point ${index + 1}: X ${Math.round(point.x)}, Y ${Math.round(point.y)}
                </span>
                <button class="btn delete-point-btn" data-point-id="${point.id}" style="padding: 2px 4px; min-height: 20px; font-size: 10px;">
                    <span class="material-icons" style="font-size: 12px;">delete</span>
                </button>
            `;

        const deleteBtn = pointItem.querySelector('.delete-point-btn');
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            removeControlPoint(point.id);
        });

        pointsList.appendChild(pointItem);
    });
}

function removeControlPoint(pointId) {
    const index = wirePoints.findIndex(p => p.id === pointId);
    if (index > -1) {
        if (wirePoints[index].element && wirePoints[index].element.parentNode) {
            wirePoints[index].element.parentNode.removeChild(wirePoints[index].element);
        }
        wirePoints.splice(index, 1);
        updatePointsList();
        updateWirePreview();
    }
}

function updateWirePreview() {
    if (!wireStartMark || !wireEndMark || !currentWireType) return;

    const existingPreview = document.querySelector('.wire-preview');
    if (existingPreview) {
        existingPreview.remove();
    }

    document.querySelectorAll('.draggable-point').forEach(el => el.remove());

    if (currentWireMode === 'curve') {
        const curveSlider = document.getElementById('wireCurveSlider');
        const curveValue = curveSlider ? parseInt(curveSlider.value) : 0;
        createCurveWirePreview(wireStartMark, wireEndMark, curveValue);
    } else {
        createPointsWirePreview(wireStartMark, wireEndMark, wirePoints);
        createDraggablePoints();
    }
}

function createCurveWirePreview(startMark, endMark, curveValue = 0) {
    const transform = getImageTransform();
    if (!transform) return;

    const startX = startMark.x * transform.scaleX + transform.imgOffsetX + (startMark.size * transform.scaleX / 2);
    const startY = startMark.y * transform.scaleY + transform.imgOffsetY + (startMark.size * transform.scaleY / 2);
    const endX = endMark.x * transform.scaleX + transform.imgOffsetX + (endMark.size * transform.scaleX / 2);
    const endY = endMark.y * transform.scaleY + transform.imgOffsetY + (endMark.size * transform.scaleY / 2);

    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("class", "wire-preview");
    svg.setAttribute("data-wire-type", currentWireType);
    svg.style.position = "absolute";
    svg.style.top = "0";
    svg.style.left = "0";
    svg.style.width = "100%";
    svg.style.height = "100%";
    svg.style.pointerEvents = "none";
    svg.style.zIndex = "5";

    const wireTypeInfo = getWireTypeInfo(currentWireType);
    const wireColor = wireTypeInfo.color;

    const dx = endX - startX;
    const dy = endY - startY;
    const distance = Math.sqrt(dx * dx + dy * dy);

    let pathData;

    if (curveValue === 0) {
        pathData = `M ${startX} ${startY} L ${endX} ${endY}`;
    } else {
        const curveFactor = Math.abs(curveValue) / 100;
        const controlDistance = distance * 0.5 * curveFactor;

        if (curveValue > 0) {
            const angle = Math.atan2(dy, dx);
            const perpendicular = angle + Math.PI / 2;

            const controlX1 = startX + Math.cos(perpendicular) * controlDistance;
            const controlY1 = startY + Math.sin(perpendicular) * controlDistance;
            const controlX2 = endX + Math.cos(perpendicular) * controlDistance;
            const controlY2 = endY + Math.sin(perpendicular) * controlDistance;

            pathData = `M ${startX} ${startY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${endX} ${endY}`;
        } else {
            const angle = Math.atan2(dy, dx);
            const perpendicular = angle - Math.PI / 2;

            const controlX1 = startX + Math.cos(perpendicular) * controlDistance;
            const controlY1 = startY + Math.sin(perpendicular) * controlDistance;
            const controlX2 = endX + Math.cos(perpendicular) * controlDistance;
            const controlY2 = endY + Math.sin(perpendicular) * controlDistance;

            pathData = `M ${startX} ${startY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${endX} ${endY}`;
        }
    }

    const path = document.createElementNS(svgNS, "path");
    path.setAttribute("d", pathData);
    path.setAttribute("stroke", wireColor + "80");
    path.setAttribute("stroke-width", "3");
    path.setAttribute("stroke-linecap", "round");
    path.setAttribute("stroke-linejoin", "round");
    path.setAttribute("fill", "none");
    path.setAttribute("stroke-dasharray", "5,5");

    svg.appendChild(path);
    imgInner.appendChild(svg);
}

function createPointsWirePreview(startMark, endMark, points) {
    const transform = getImageTransform();
    if (!transform) return;

    const startX = startMark.x * transform.scaleX + transform.imgOffsetX + (startMark.size * transform.scaleX / 2);
    const startY = startMark.y * transform.scaleY + transform.imgOffsetY + (startMark.size * transform.scaleY / 2);
    const endX = endMark.x * transform.scaleX + transform.imgOffsetX + (endMark.size * transform.scaleX / 2);
    const endY = endMark.y * transform.scaleY + transform.imgOffsetY + (endMark.size * transform.scaleY / 2);

    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("class", "wire-preview");
    svg.setAttribute("data-wire-type", currentWireType);
    svg.style.position = "absolute";
    svg.style.top = "0";
    svg.style.left = "0";
    svg.style.width = "100%";
    svg.style.height = "100%";
    svg.style.pointerEvents = "none";
    svg.style.zIndex = "5";

    const wireTypeInfo = getWireTypeInfo(currentWireType);
    const wireColor = wireTypeInfo.color;

    let pathData = `M ${startX} ${startY}`;

    points.forEach(point => {
        const pointX = point.x * transform.scaleX + transform.imgOffsetX;
        const pointY = point.y * transform.scaleY + transform.imgOffsetY;
        pathData += ` L ${pointX} ${pointY}`;
    });

    pathData += ` L ${endX} ${endY}`;

    const path = document.createElementNS(svgNS, "path");
    path.setAttribute("d", pathData);
    path.setAttribute("stroke", wireColor + "80");
    path.setAttribute("stroke-width", "3");
    path.setAttribute("stroke-linecap", "round");
    path.setAttribute("stroke-linejoin", "round");
    path.setAttribute("fill", "none");
    path.setAttribute("stroke-dasharray", "5,5");

    svg.appendChild(path);
    imgInner.appendChild(svg);
}

function createDraggablePoints() {
    const transform = getImageTransform();
    if (!transform) return;

    const wireTypeInfo = getWireTypeInfo(currentWireType);

    wirePoints.forEach((point, index) => {
        if (point.element && point.element.parentNode) {
            point.element.parentNode.removeChild(point.element);
        }

        const pointEl = document.createElement('div');
        pointEl.className = 'draggable-point';
        pointEl.dataset.pointId = point.id;
        pointEl.dataset.pointIndex = index;
        pointEl.style.position = 'absolute';
        pointEl.style.width = '16px';
        pointEl.style.height = '16px';
        pointEl.style.background = wireTypeInfo.color;
        pointEl.style.border = '2px solid white';
        pointEl.style.borderRadius = '50%';
        pointEl.style.cursor = 'move';
        pointEl.style.zIndex = '10';
        pointEl.style.boxShadow = '0 2px 6px rgba(0,0,0,0.3)';
        pointEl.style.transition = 'all 0.2s ease';

        const x = point.x * transform.scaleX + transform.imgOffsetX - 8;
        const y = point.y * transform.scaleY + transform.imgOffsetY - 8;
        pointEl.style.left = x + 'px';
        pointEl.style.top = y + 'px';

        point.element = pointEl;
        setupPointDragging(point, pointEl, index);

        pointEl.addEventListener('click', (e) => {
            e.stopPropagation();
        });

        imgInner.appendChild(pointEl);
    });
}

function setupPointDragging(point, pointEl, index) {
    let isDragging = false;
    let dragStartX = 0, dragStartY = 0;
    let pointStartX = 0, pointStartY = 0;

    pointEl.addEventListener('mousedown', (e) => {
        e.preventDefault();
        e.stopPropagation();
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        pointStartX = point.x;
        pointStartY = point.y;
        pointEl.style.cursor = 'grabbing';
        pointEl.style.zIndex = '11';
        pointEl.classList.add('dragging');
        pointEl.style.transform = 'scale(1.4)';
        pointEl.style.boxShadow = '0 6px 12px rgba(0,0,0,0.5)';
    });

    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;

        const dx = e.clientX - dragStartX;
        const dy = e.clientY - dragStartY;

        const transform = getImageTransform();
        if (!transform) return;

        const imgRect = previewImage.getBoundingClientRect();
        const scaleX = imageNaturalWidth / imgRect.width;
        const scaleY = imageNaturalHeight / imgRect.height;

        const imageDx = dx * scaleX;
        const imageDy = dy * scaleY;

        point.x = pointStartX + imageDx;
        point.y = pointStartY + imageDy;

        point.x = Math.max(0, Math.min(imageNaturalWidth, point.x));
        point.y = Math.max(0, Math.min(imageNaturalHeight, point.y));

        const newX = point.x * transform.scaleX + transform.imgOffsetX - 8;
        const newY = point.y * transform.scaleY + transform.imgOffsetY - 8;
        pointEl.style.left = newX + 'px';
        pointEl.style.top = newY + 'px';

        updateWirePreview();
    });

    document.addEventListener('mouseup', () => {
        if (isDragging) {
            isDragging = false;
            pointEl.style.cursor = 'move';
            pointEl.style.zIndex = '10';
            pointEl.classList.remove('dragging');
            pointEl.style.transform = 'scale(1.2)';
            pointEl.style.boxShadow = '0 4px 8px rgba(0,0,0,0.4)';
            updatePointsList();
        }
    });
}

function createWire() {
    if (!wireStartMark || !wireEndMark || !currentWireType) {
        alert('Please select two marks to connect');
        return;
    }

    if (wireStartMark === wireEndMark) {
        alert('Cannot connect a mark to itself');
        return;
    }

    const wireElement = currentWireMode === 'curve'
        ? createCurveWire(wireStartMark, wireEndMark)
        : createPointsWire(wireStartMark, wireEndMark, wirePoints);

    if (!wireElement) return;

    const wire = {
        id: `wire-${Date.now()}`,
        startMark: wireStartMark,
        endMark: wireEndMark,
        element: wireElement,
        mode: currentWireMode,
        curveValue: currentWireMode === 'curve' ? parseInt(document.getElementById('wireCurveSlider').value) : 0,
        points: currentWireMode === 'points' ? wirePoints.map(p => ({ x: p.x, y: p.y })) : [],
        wireType: currentWireType,
        color: getWireTypeInfo(currentWireType).color
    };

    wires.push(wire);

    document.querySelectorAll('.draggable-point').forEach(el => el.remove());
    wirePoints = [];

    updateWiresList();
    resetWireSelection();

    const wireTypeInfo = getWireTypeInfo(currentWireType);
    showNotification(`${wireTypeInfo.title} created between ${wireStartMark.seriesLabel} and ${wireEndMark.seriesLabel}`, 'success');
}

function createCurveWire(startMark, endMark) {
    const transform = getImageTransform();
    if (!transform) return null;

    const curveSlider = document.getElementById('wireCurveSlider');
    const curveValue = curveSlider ? parseInt(curveSlider.value) : 0;

    return createWireElement(startMark, endMark, curveValue, false);
}

function createPointsWire(startMark, endMark, points) {
    const transform = getImageTransform();
    if (!transform) return null;

    return createWireElementWithPoints(startMark, endMark, points, false);
}

function createWireElementWithPoints(startMark, endMark, points, isPreview = false) {
    const transform = getImageTransform();
    if (!transform) return null;

    const startX = startMark.x * transform.scaleX + transform.imgOffsetX + (startMark.size * transform.scaleX / 2);
    const startY = startMark.y * transform.scaleY + transform.imgOffsetY + (startMark.size * transform.scaleY / 2);
    const endX = endMark.x * transform.scaleX + transform.imgOffsetX + (endMark.size * transform.scaleX / 2);
    const endY = endMark.y * transform.scaleY + transform.imgOffsetY + (endMark.size * transform.scaleY / 2);

    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("class", isPreview ? "wire-preview" : "wire");
    svg.setAttribute("data-wire-type", currentWireType);
    svg.style.position = "absolute";
    svg.style.top = "0";
    svg.style.left = "0";
    svg.style.width = "100%";
    svg.style.height = "100%";
    svg.style.pointerEvents = isPreview ? "none" : "auto";
    svg.style.zIndex = isPreview ? "5" : "9";

    const wireTypeInfo = getWireTypeInfo(currentWireType);
    const wireColor = wireTypeInfo.color;

    let pathData = `M ${startX} ${startY}`;

    points.forEach(point => {
        const pointX = point.x * transform.scaleX + transform.imgOffsetX;
        const pointY = point.y * transform.scaleY + transform.imgOffsetY;
        pathData += ` L ${pointX} ${pointY}`;
    });

    pathData += ` L ${endX} ${endY}`;

    const path = document.createElementNS(svgNS, "path");
    path.setAttribute("d", pathData);
    path.setAttribute("stroke", isPreview ? wireColor + "80" : wireColor);
    path.setAttribute("stroke-width", isPreview ? "3" : "4");
    path.setAttribute("stroke-linecap", "round");
    path.setAttribute("stroke-linejoin", "round");
    path.setAttribute("fill", "none");
    path.setAttribute("stroke-dasharray", isPreview ? "5,5" : "none");

    if (!isPreview) {
        path.style.cursor = "pointer";
        path.addEventListener('click', function (e) {
            e.stopPropagation();
            selectWire(startMark, endMark, currentWireType);
        });

        makeWireDraggable(path, startMark, endMark);
    }

    svg.appendChild(path);

    const startCircle = document.createElementNS(svgNS, "circle");
    startCircle.setAttribute("cx", startX);
    startCircle.setAttribute("cy", startY);
    startCircle.setAttribute("r", "6");
    startCircle.setAttribute("fill", wireColor);
    startCircle.setAttribute("stroke", "#fff");
    startCircle.setAttribute("stroke-width", "2");

    const endCircle = document.createElementNS(svgNS, "circle");
    endCircle.setAttribute("cx", endX);
    endCircle.setAttribute("cy", endY);
    endCircle.setAttribute("r", "6");
    endCircle.setAttribute("fill", wireColor);
    endCircle.setAttribute("stroke", "#fff");
    endCircle.setAttribute("stroke-width", "2");

    svg.appendChild(startCircle);
    svg.appendChild(endCircle);

    imgInner.appendChild(svg);

    return {
        svg,
        path,
        startCircle,
        endCircle,
        startX, startY, endX, endY
    };
}

function createWireElement(startMark, endMark, curveValue = 0, isPreview = false) {
    const transform = getImageTransform();
    if (!transform) return null;

    const startX = startMark.x * transform.scaleX + transform.imgOffsetX + (startMark.size * transform.scaleX / 2);
    const startY = startMark.y * transform.scaleY + transform.imgOffsetY + (startMark.size * transform.scaleY / 2);
    const endX = endMark.x * transform.scaleX + transform.imgOffsetX + (endMark.size * transform.scaleX / 2);
    const endY = endMark.y * transform.scaleY + transform.imgOffsetY + (endMark.size * transform.scaleY / 2);

    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("class", isPreview ? "wire-preview" : "wire");
    svg.setAttribute("data-wire-type", currentWireType);
    svg.style.position = "absolute";
    svg.style.top = "0";
    svg.style.left = "0";
    svg.style.width = "100%";
    svg.style.height = "100%";
    svg.style.pointerEvents = isPreview ? "none" : "auto";
    svg.style.zIndex = isPreview ? "5" : "9";

    const wireTypeInfo = getWireTypeInfo(currentWireType);
    const wireColor = wireTypeInfo.color;

    const dx = endX - startX;
    const dy = endY - startY;
    const distance = Math.sqrt(dx * dx + dy * dy);

    let pathData;

    if (curveValue === 0) {
        pathData = `M ${startX} ${startY} L ${endX} ${endY}`;
    } else {
        const curveFactor = Math.abs(curveValue) / 100;
        const controlDistance = distance * 0.5 * curveFactor;

        if (curveValue > 0) {
            const angle = Math.atan2(dy, dx);
            const perpendicular = angle + Math.PI / 2;

            const controlX1 = startX + Math.cos(perpendicular) * controlDistance;
            const controlY1 = startY + Math.sin(perpendicular) * controlDistance;
            const controlX2 = endX + Math.cos(perpendicular) * controlDistance;
            const controlY2 = endY + Math.sin(perpendicular) * controlDistance;

            pathData = `M ${startX} ${startY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${endX} ${endY}`;
        } else {
            const angle = Math.atan2(dy, dx);
            const perpendicular = angle - Math.PI / 2;

            const controlX1 = startX + Math.cos(perpendicular) * controlDistance;
            const controlY1 = startY + Math.sin(perpendicular) * controlDistance;
            const controlX2 = endX + Math.cos(perpendicular) * controlDistance;
            const controlY2 = endY + Math.sin(perpendicular) * controlDistance;

            pathData = `M ${startX} ${startY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${endX} ${endY}`;
        }
    }

    const path = document.createElementNS(svgNS, "path");
    path.setAttribute("d", pathData);
    path.setAttribute("stroke", isPreview ? wireColor + "80" : wireColor);
    path.setAttribute("stroke-width", isPreview ? "3" : "4");
    path.setAttribute("stroke-linecap", "round");
    path.setAttribute("stroke-linejoin", "round");
    path.setAttribute("fill", "none");
    path.setAttribute("stroke-dasharray", isPreview ? "5,5" : "none");

    if (!isPreview) {
        path.style.cursor = "pointer";
        path.addEventListener('click', function (e) {
            e.stopPropagation();
            selectWire(startMark, endMark, currentWireType);
        });

        makeWireDraggable(path, startMark, endMark);
    }

    svg.appendChild(path);

    const startCircle = document.createElementNS(svgNS, "circle");
    startCircle.setAttribute("cx", startX);
    startCircle.setAttribute("cy", startY);
    startCircle.setAttribute("r", "6");
    startCircle.setAttribute("fill", wireColor);
    startCircle.setAttribute("stroke", "#fff");
    startCircle.setAttribute("stroke-width", "2");

    const endCircle = document.createElementNS(svgNS, "circle");
    endCircle.setAttribute("cx", endX);
    endCircle.setAttribute("cy", endY);
    endCircle.setAttribute("r", "6");
    endCircle.setAttribute("fill", wireColor);
    endCircle.setAttribute("stroke", "#fff");
    endCircle.setAttribute("stroke-width", "2");

    svg.appendChild(startCircle);
    svg.appendChild(endCircle);

    imgInner.appendChild(svg);

    return {
        svg,
        path,
        startCircle,
        endCircle,
        startX, startY, endX, endY,
        curveValue
    };
}

function makeWireDraggable(pathElement, startMark, endMark) {
    let isDragging = false;
    let startDragX = 0, startDragY = 0;
    let originalStartX = 0, originalStartY = 0, originalEndX = 0, originalEndY = 0;

    pathElement.addEventListener('mousedown', function (e) {
        isDragging = true;
        startDragX = e.clientX;
        startDragY = e.clientY;

        const transform = getImageTransform();
        if (transform) {
            originalStartX = startMark.x * transform.scaleX + transform.imgOffsetX + (startMark.size * transform.scaleX / 2);
            originalStartY = startMark.y * transform.scaleY + transform.imgOffsetY + (startMark.size * transform.scaleY / 2);
            originalEndX = endMark.x * transform.scaleX + transform.imgOffsetX + (endMark.size * transform.scaleX / 2);
            originalEndY = endMark.y * transform.scaleY + transform.imgOffsetY + (endMark.size * transform.scaleY / 2);
        }

        e.stopPropagation();
    });

    document.addEventListener('mousemove', function (e) {
        if (!isDragging) return;

        const dx = e.clientX - startDragX;
        const dy = e.clientY - startDragY;

        const newStartX = originalStartX + dx;
        const newStartY = originalStartY + dy;
        const newEndX = originalEndX + dx;
        const newEndY = originalEndY + dy;

        const transform = getImageTransform();
        if (!transform) return;

        const scaleX = transform.scaleX;
        const scaleY = transform.scaleY;
        const imgOffsetX = transform.imgOffsetX;
        const imgOffsetY = transform.imgOffsetY;

        startMark.x = (newStartX - imgOffsetX - (startMark.size * scaleX / 2)) / scaleX;
        startMark.y = (newStartY - imgOffsetY - (startMark.size * scaleY / 2)) / scaleY;

        endMark.x = (newEndX - imgOffsetX - (endMark.size * scaleX / 2)) / scaleX;
        endMark.y = (newEndY - imgOffsetY - (endMark.size * scaleY / 2)) / scaleY;

        updateMarkPosition(startMark);
        updateMarkPosition(endMark);

        updateAllWires(currentWireType);

        e.preventDefault();
    });

    document.addEventListener('mouseup', function () {
        isDragging = false;
    });
}

function cancelWire() {
    resetWireSelection();
}

function selectWire(startMark, endMark, wireType) {
    selectedWire = { startMark, endMark, wireType };

    wires.forEach(wire => {
        if ((wire.startMark === startMark && wire.endMark === endMark && wire.wireType === wireType) ||
            (wire.startMark === endMark && wire.endMark === startMark && wire.wireType === wireType)) {
            wire.element.path.setAttribute('stroke-width', '6');
        } else {
            wire.element.path.setAttribute('stroke-width', '4');
        }
    });

    showWireEditOptions(startMark, endMark, wireType);
}

function showWireEditOptions(startMark, endMark, wireType) {
    const existingEdit = document.querySelector('.wire-edit-controls');
    if (existingEdit) {
        existingEdit.remove();
    }

    const wire = wires.find(w =>
        ((w.startMark === startMark && w.endMark === endMark) ||
            (w.startMark === endMark && w.endMark === startMark)) &&
        w.wireType === wireType
    );

    if (!wire) return;

    const wireTypeInfo = getWireTypeInfo(wireType);

    const editHTML = `
            <div class="mark-controls-box wire-edit-controls" style="margin-top: 20px; border-color: ${wireTypeInfo.color};">
                <h3 style="color: ${wireTypeInfo.color};">
                    <span class="material-icons" style="font-size: 18px; vertical-align: middle; margin-right: 8px;">edit</span>
                    Edit ${wireTypeInfo.title}
                </h3>
                
                <div class="form-group">
                    <div style="background: ${wireTypeInfo.bgColor}; padding: 12px; border-radius: 8px; margin-bottom: 16px; border: 1px solid ${wireTypeInfo.borderColor};">
                        <div style="font-size: 12px; color: ${wireTypeInfo.color}; margin-bottom: 8px;">
                            <span class="material-icons" style="font-size: 14px; vertical-align: middle; margin-right: 4px;">link</span>
                            ${wireTypeInfo.title} between <strong>${startMark.seriesLabel}</strong> and <strong>${endMark.seriesLabel}</strong>
                        </div>
                        <div style="font-size: 11px; color: #555;">
                            Mode: ${wire.mode === 'curve' ? 'Curve' : 'Points'} 
                            ${wire.mode === 'curve' ? `â€¢ Curve level: ${wire.curveValue}` : `â€¢ Points: ${wire.points.length}`}
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <button id="deleteWireBtn" class="btn full-width" style="border-color: #f44336; color: #f44336;">
                        <span class="material-icons" style="font-size: 16px; margin-right: 8px;">delete</span>
                        Delete Wire
                    </button>
                    <button id="closeEditBtn" class="btn full-width" style="margin-top: 8px;">
                        <span class="material-icons" style="font-size: 16px; margin-right: 8px;">close</span>
                        Close
                    </button>
                </div>
            </div>
        `;

    const wireControls = document.getElementById('wireControls');
    if (wireControls) {
        wireControls.insertAdjacentHTML('afterend', editHTML);

        document.getElementById('deleteWireBtn').addEventListener('click', function () {
            deleteWire(wire);
        });

        document.getElementById('closeEditBtn').addEventListener('click', function () {
            const editControls = document.querySelector('.wire-edit-controls');
            if (editControls) {
                editControls.remove();
            }

            wires.forEach(wire => {
                wire.element.path.setAttribute('stroke-width', '4');
            });

            selectedWire = null;
        });
    }
}

function updateWireDisplay(wire) {
    if (wire.element && wire.element.svg) {
        wire.element.svg.remove();
    }

    let newElement;
    if (wire.mode === 'curve') {
        const curveSlider = document.getElementById('editWireCurveSlider');
        const newCurveValue = curveSlider ? parseInt(curveSlider.value) : wire.curveValue;
        wire.curveValue = newCurveValue;
        newElement = createWireElement(wire.startMark, wire.endMark, newCurveValue, false);
    } else {
        newElement = createWireElementWithPoints(wire.startMark, wire.endMark, wire.points, false);
    }

    wire.element = newElement;
}

function updateWire(wire) {
    if (wire.mode === 'curve') {
        const slider = document.getElementById('editWireCurveSlider');
        const newCurveValue = slider ? parseInt(slider.value) : wire.curveValue;
        wire.curveValue = newCurveValue;
    }

    updateWireDisplay(wire);

    const wireTypeInfo = getWireTypeInfo(wire.wireType);
    showNotification(`${wireTypeInfo.title} updated successfully`, 'success');
}

function deleteWire(wire) {
    if (wire.element && wire.element.svg) {
        wire.element.svg.remove();
    }

    const index = wires.indexOf(wire);
    if (index > -1) {
        wires.splice(index, 1);
    }

    const editControls = document.querySelector('.wire-edit-controls');
    if (editControls) {
        editControls.remove();
    }

    updateWiresList();

    const wireTypeInfo = getWireTypeInfo(wire.wireType);
    showNotification(`${wireTypeInfo.title} deleted successfully`, 'success');
    selectedWire = null;
}

function updateAllWires(wireType = null) {
    wires.forEach(wire => {
        if (!wireType || wire.wireType === wireType) {
            if (wire.element && wire.element.svg) {
                wire.element.svg.remove();
            }

            let newElement;
            if (wire.mode === 'curve') {
                newElement = createWireElement(wire.startMark, wire.endMark, wire.curveValue, false);
            } else {
                newElement = createWireElementWithPoints(wire.startMark, wire.endMark, wire.points, false);
            }
            wire.element = newElement;
        }
    });
}

function updateWiresList() {
    const wiresList = document.getElementById('wiresList');
    if (!wiresList || !currentWireType) return;

    wiresList.innerHTML = '';

    const typeWires = wires.filter(wire => wire.wireType === currentWireType);

    if (typeWires.length === 0) {
        const wireTypeInfo = getWireTypeInfo(currentWireType);
        wiresList.innerHTML = `<div style="color: var(--muted); font-size: 12px; text-align: center; padding: 8px;">No ${wireTypeInfo.title.toLowerCase()}s created yet</div>`;
        return;
    }

    typeWires.forEach((wire, index) => {
        const wireItem = document.createElement('div');
        wireItem.className = 'mark-item';
        wireItem.style.borderColor = wire.color;
        wireItem.style.background = wire.color + '10';

        wireItem.innerHTML = `
                <span style="flex: 1; font-size: 12px;">
                    <span style="font-weight: bold; color: ${wire.color};">${wire.startMark.seriesLabel}</span>
                    <span class="material-icons" style="font-size: 12px; vertical-align: middle; margin: 0 4px; color: ${wire.color};">arrow_forward</span>
                    <span style="font-weight: bold; color: ${wire.color};">${wire.endMark.seriesLabel}</span>
                    <span style="font-size: 10px; color: #666; margin-left: 8px;">${wire.mode === 'curve' ? 'Curve: ' + wire.curveValue : 'Points: ' + wire.points.length}</span>
                </span>
                <button class="btn" style="padding: 4px 6px; min-height: 24px; font-size: 11px; opacity: 0.7;">
                    <span class="material-icons" style="font-size: 14px;">delete</span>
                </button>
            `;

        wireItem.addEventListener('click', function (e) {
            if (!e.target.closest('button')) {
                selectWire(wire.startMark, wire.endMark, wire.wireType);
            }
        });

        const deleteBtn = wireItem.querySelector('button');
        deleteBtn.addEventListener('click', function (e) {
            e.stopPropagation();
            deleteWire(wire);
        });

        wiresList.appendChild(wireItem);
    });
}

/* ------------------------- MARKS & DRAGGING ------------------------- */
const marksListEl = document.getElementById('marksList');
const addMarkBtn = document.getElementById('addMarkBtn');
const markShapeEl = document.getElementById('markShape');
const markSizeEl = document.getElementById('markSizeText');

let markCounter = 0;

previewImage.addEventListener('load', updateImageDimensions);
window.addEventListener('resize', updateImageDimensions);

function getImageTransform() {
    const img = previewImage;
    const containerRect = imgContainer.getBoundingClientRect();

    // Get the actual rendered image dimensions
    const imgRect = img.getBoundingClientRect();

    // Calculate natural dimensions, fallback to displayed if not available
    let naturalWidth = img.naturalWidth || imgRect.width;
    let naturalHeight = img.naturalHeight || imgRect.height;

    // If natural dimensions are 0 or invalid, use the displayed dimensions
    if (naturalWidth <= 0 || naturalHeight <= 0) {
        naturalWidth = imgRect.width;
        naturalHeight = imgRect.height;
    }

    imageNaturalWidth = naturalWidth;
    imageNaturalHeight = naturalHeight;

    if (!imageNaturalWidth || !imageNaturalHeight) return null;

    const imgAspect = imageNaturalWidth / imageNaturalHeight;
    const containerAspect = containerRect.width / containerRect.height;

    let displayWidth, displayHeight, imgOffsetX, imgOffsetY;

    // Calculate how the image is actually displayed with object-fit: contain
    if (imgAspect > containerAspect) {
        // Image is wider than container
        displayWidth = containerRect.width;
        displayHeight = containerRect.width / imgAspect;
        imgOffsetX = 0;
        imgOffsetY = (containerRect.height - displayHeight) / 2;
    } else {
        // Image is taller than container
        displayHeight = containerRect.height;
        displayWidth = containerRect.height * imgAspect;
        imgOffsetX = (containerRect.width - displayWidth) / 2;
        imgOffsetY = 0;
    }

    imageDisplayWidth = displayWidth;
    imageDisplayHeight = displayHeight;

    return {
        imgOffsetX,
        imgOffsetY,
        scaleX: displayWidth / imageNaturalWidth,
        scaleY: displayHeight / imageNaturalHeight
    };
}

// Add this function near the top with other utility functions
function getActualImageDimensions() {
    const img = previewImage;
    const containerRect = imgContainer.getBoundingClientRect();

    // Get the actual rendered dimensions
    const imgRect = img.getBoundingClientRect();

    // Calculate natural dimensions
    let naturalWidth = img.naturalWidth || imgRect.width;
    let naturalHeight = img.naturalHeight || imgRect.height;

    // Calculate displayed dimensions based on object-fit: contain
    const imgAspect = naturalWidth / naturalHeight;
    const containerAspect = containerRect.width / containerRect.height;

    let displayWidth, displayHeight;

    if (imgAspect > containerAspect) {
        displayWidth = containerRect.width;
        displayHeight = containerRect.width / imgAspect;
    } else {
        displayHeight = containerRect.height;
        displayWidth = containerRect.height * imgAspect;
    }

    return {
        naturalWidth,
        naturalHeight,
        displayWidth,
        displayHeight
    };
}

function updateImageDimensions() {
    const transform = getImageTransform();
    if (transform) {
        // Also store the actual displayed image position for reference
        const img = previewImage;
        const imgRect = img.getBoundingClientRect();
        const containerRect = imgContainer.getBoundingClientRect();

        // Calculate the actual visible area of the image
        const imgActual = getActualImageDimensions();

        // Update marks and wires with the accurate transform
        updateAllMarks();
        updateAllWires();

        console.log('Image updated:', {
            natural: `${imgActual.naturalWidth}x${imgActual.naturalHeight}`,
            displayed: `${Math.round(imgActual.displayWidth)}x${Math.round(imgActual.displayHeight)}`,
            container: `${Math.round(containerRect.width)}x${Math.round(containerRect.height)}`,
            scale: `${transform.scaleX.toFixed(4)}x${transform.scaleY.toFixed(4)}`,
            offset: `${Math.round(transform.imgOffsetX)}x${Math.round(transform.imgOffsetY)}`
        });
    }
}

function updateAllMarks() {
    marks.forEach(mark => {
        updateMarkPosition(mark);
    });
}

function updateMarkPosition(mark) {
    const transform = getImageTransform();
    if (!transform) return;

    const x = mark.x * transform.scaleX + transform.imgOffsetX;
    const y = mark.y * transform.scaleY + transform.imgOffsetY;
    const size = mark.size * transform.scaleX;

    mark.el.style.left = x + 'px';
    mark.el.style.top = y + 'px';
    mark.el.style.width = size + 'px';
    mark.el.style.height = size + 'px';
    orientTooltip(mark);
}

function renumberAllMarks() {
    const marksByCode = {};
    marks.forEach(mark => {
        if (!marksByCode[mark.seriesCode]) {
            marksByCode[mark.seriesCode] = [];
        }
        marksByCode[mark.seriesCode].push(mark);
    });

    Object.keys(marksByCode).forEach(code => {
        marksByCode[code].sort((a, b) => {
            const numA = parseInt(a.id.split('-')[1]);
            const numB = parseInt(b.id.split('-')[1]);
            return numA - numB;
        });

        marksByCode[code].forEach((mark, index) => {
            const newLabel = `${code}${index + 1}`;

            mark.seriesLabel = newLabel;

            const badge = mark.el.querySelector('.label-badge');
            if (badge) {
                badge.textContent = newLabel;
            }
        });

        seriesCounters[code] = marksByCode[code].length;
    });
}

addMarkBtn.addEventListener('click', () => {
    if (!currentProduct) {
        alert('Please select a product first');
        return;
    }
    const data = productData[currentProduct];
    if (data.subProducts && !data.isDBBox && currentProduct !== 'Z-WAVE RELAY' && !currentSubProduct) {
        alert('Please select a model first');
        return;
    }

    const shape = markShapeEl.value;
    let sizePercent = parseFloat(markSizeEl.value) || 4;
    if (sizePercent <= 0) sizePercent = 4;

    if (imageNaturalWidth && imageNaturalHeight) {
        const sizePixels = (sizePercent / 100) * Math.min(imageNaturalWidth, imageNaturalHeight);
        const centerX = imageNaturalWidth / 2;
        const centerY = imageNaturalHeight / 2;

        createMark({
            x: centerX - (sizePixels / 2),
            y: centerY - (sizePixels / 2),
            size: sizePixels,
            shape: shape
        });
    } else {
        createMark({
            x: 50,
            y: 50,
            size: 50,
            shape: shape
        });
    }
});

function createMark({ x, y, size, shape }) {
    const id = 'mark-' + (++markCounter);

    const productDataForMark = currentSubProduct && productData[currentProduct]?.subProducts?.[currentSubProduct]
        ? productData[currentProduct].subProducts[currentSubProduct]
        : productData[currentProduct] || {};

    if (!currentProduct) {
        alert('Please select a product first');
        return;
    }

    const data = productData[currentProduct];
    const needsModel = data.subProducts && currentProduct !== 'Z-WAVE RELAY' && !data.isDBBox;
    if (needsModel && !currentSubProduct) {
        alert('Select a model before adding a label');
        return;
    }

    let relayItems = [];
    if (currentProduct === 'Z-WAVE RELAY') {
        relayItems = getSelectedRelayItems();
        if (relayItems.length === 0) {
            alert('Select at least one relay module and quantity');
            return;
        }
        lastRelaySelectionLabel = relayItems[relayItems.length - 1].name;
        updateRelayOverlay();
    }

    const { seriesCode, label } = nextSeriesLabel(currentProduct);

    const fallbackProduct = productData[currentProduct] || {};
    const fallbackImg = productDataForMark?.img || fallbackProduct.img || previewImage.src;
    const categoryName = currentProduct || '';

    let modelName = '';
    let featuresList = [];
    let descText = '';
    let brand = '';
    let sizeFt = '';

    if (data.isDBBox) {
        brand = productData[currentProduct].brand || '';
        sizeFt = productData[currentProduct].size || '';
        modelName = brand ? `${brand} - ${sizeFt} ft` : 'DB Box';
        descText = `${categoryName}: ${brand} ${sizeFt} ft`;
        featuresList = productDataForMark.features || [];
    } else if (currentProduct === 'Z-WAVE RELAY') {
        modelName = relayItems.length === 1 ? relayItems[0].name : `${relayItems.length} modules selected`;
        featuresList = relayItems.map(item => `${item.name} â€” Qty ${item.quantity}`);
        descText = productDataForMark?.desc || fallbackProduct.desc || '';
    } else {
        modelName = productDataForMark?.title || fallbackProduct.title || '';
        featuresList = (productDataForMark?.features || fallbackProduct.features || []).slice();
        descText = productDataForMark?.desc || fallbackProduct.desc || '';
    }

    const el = document.createElement('div');
    el.className = 'mark ' + shape;
    el.dataset.id = id;
    el.dataset.size = size;
    el.dataset.shape = shape;

    const badge = document.createElement('div');
    badge.className = 'label-badge';
    badge.textContent = label;
    el.appendChild(badge);

    const tooltip = document.createElement('div');
    tooltip.className = 'tooltip';

    const tooltipContent = document.createElement('div');
    tooltipContent.className = 'tooltip-content';

    const tooltipTitle = document.createElement('div');
    tooltipTitle.className = 'tooltip-title';
    tooltipTitle.textContent = categoryName || 'Product';

    const tooltipModel = document.createElement('div');
    tooltipModel.className = 'tooltip-model';
    tooltipModel.textContent = modelName || 'â€”';

    tooltipContent.appendChild(tooltipTitle);
    tooltipContent.appendChild(tooltipModel);
    tooltip.appendChild(tooltipContent);
    el.appendChild(tooltip);

    imgInner.appendChild(el);

    const markData = {
        id,
        x,
        y,
        size,
        shape,
        el,
        productData: productDataForMark,
        seriesCode,
        seriesLabel: label,
        tooltip,
        categoryName,
        modelName,
        desc: descText,
        features: featuresList,
        imageSrc: fallbackImg,
        relayItems,
        brand: brand,
        sizeFt: sizeFt,
        isDBBox: data.isDBBox || false
    };

    marks.push(markData);

    el.addEventListener('click', function (e) {
        if (isWireMode && currentWireType && !e.defaultPrevented) {
            if (!wireStartMark) {
                wireStartMark = markData;
                showNotification(`First mark selected: ${label}. Now select second mark.`, 'info');
            } else if (!wireEndMark && wireStartMark !== markData) {
                wireEndMark = markData;
                const wireTypeInfo = getWireTypeInfo(currentWireType);
                showNotification(`Second mark selected: ${label}. ${currentWireMode === 'curve' ? 'Adjust curve' : 'Add points'} and click "Create ${wireTypeInfo.title}".`, 'info');
            } else if (wireStartMark === markData) {
                wireStartMark = null;
                wireEndMark = null;
                wirePoints = [];
                showNotification('First mark selection cleared.', 'info');
            } else if (wireEndMark === markData) {
                wireEndMark = null;
                wirePoints = [];
                showNotification('Second mark selection cleared.', 'info');
            }
            updateWireSelectionLabels();
            updatePointsList();
            e.preventDefault();
            e.stopPropagation();
        }
    });

    let dragging = false;
    let startX = 0, startY = 0;
    let startMarkX = 0, startMarkY = 0;
    let dragStarted = false;

    function onPointerDown(ev) {
        ev.stopPropagation();
        ev.preventDefault();
        el.setPointerCapture(ev.pointerId);
        dragging = true;
        dragStarted = false;
        startX = ev.clientX;
        startY = ev.clientY;
        startMarkX = markData.x;
        startMarkY = markData.y;
        selectedMarkId = id;
        updateMarkSelection();
        el.classList.add('selected');
    }

    function onPointerMove(ev) {
        if (!dragging) return;

        const dx = ev.clientX - startX;
        const dy = ev.clientY - startY;

        if (!dragStarted && (Math.abs(dx) > 3 || Math.abs(dy) > 3)) {
            dragStarted = true;
        }

        if (!dragStarted) return;

        ev.preventDefault();
        ev.stopPropagation();

        const transform = getImageTransform();
        if (!transform || !imageNaturalWidth || !imageNaturalHeight) return;

        const imgRect = previewImage.getBoundingClientRect();

        const scaleX = imageNaturalWidth / imgRect.width;
        const scaleY = imageNaturalHeight / imgRect.height;

        const imageDx = dx * scaleX;
        const imageDy = dy * scaleY;

        let newX = startMarkX + imageDx;
        let newY = startMarkY + imageDy;

        newX = Math.max(0, Math.min(imageNaturalWidth - markData.size, newX));
        newY = Math.max(0, Math.min(imageNaturalHeight - markData.size, newY));

        markData.x = newX;
        markData.y = newY;

        updateMarkPosition(markData);
        updateAllWires();
    }

    function onPointerUp(ev) {
        if (dragging) {
            dragging = false;
            dragStarted = false;
            try {
                el.releasePointerCapture(ev.pointerId);
            } catch (e) { }
            el.classList.remove('selected');

            if (!dragStarted && !isWireMode) {
                selectedMarkId = id;
                updateMarkSelection();
                openProductModal(markData);
            }
        }
    }

    el.addEventListener('pointerdown', onPointerDown);
    el.addEventListener('mouseenter', () => orientTooltip(markData));
    document.addEventListener('pointermove', onPointerMove);
    document.addEventListener('pointerup', onPointerUp);

    updateMarkPosition(markData);
    updateMarkSelection();
}

function updateMarkSelection() {
    marks.forEach(m => {
        m.el.classList.toggle('selected', m.id === selectedMarkId);
    });
    renderMarksList();
}

function removeMark(id) {
    const idx = marks.findIndex(x => x.id === id);
    if (idx === -1) return;
    const m = marks[idx];

    const connectedWires = wires.filter(w => w.startMark === m || w.endMark === m);
    connectedWires.forEach(wire => {
        if (wire.element && wire.element.svg) {
            wire.element.svg.remove();
        }
        const wireIndex = wires.indexOf(wire);
        if (wireIndex > -1) {
            wires.splice(wireIndex, 1);
        }
    });

    if (m.el && m.el.parentNode) {
        m.el.parentNode.removeChild(m.el);
    }
    marks.splice(idx, 1);
    if (selectedMarkId === id) {
        selectedMarkId = null;
    }

    updateWiresList();
    renumberAllMarks();
    updateMarkSelection();
}

function renderMarksList() {
    marksListEl.innerHTML = '';
    if (marks.length === 0) {
        const empty = document.createElement('div');
        empty.style.color = 'var(--muted)';
        empty.style.fontSize = '12px';
        empty.style.padding = '8px';
        empty.textContent = 'No marks added yet';
        marksListEl.appendChild(empty);
        return;
    }

    marks.forEach(m => {
        const item = document.createElement('div');
        item.className = 'mark-item';
        item.classList.toggle('active', m.id === selectedMarkId);

        const label = document.createElement('span');
        label.textContent = m.seriesLabel;
        item.appendChild(label);

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'btn';
        deleteBtn.innerHTML = '<span class="material-icons" style="font-size:16px;">close</span>';
        deleteBtn.style.marginLeft = '8px';
        deleteBtn.style.padding = '4px 6px';
        deleteBtn.style.minHeight = 'auto';
        deleteBtn.style.fontSize = '12px';
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            removeMark(m.id);
        });
        item.appendChild(deleteBtn);

        item.addEventListener('click', (e) => {
            if (e.target !== deleteBtn && !deleteBtn.contains(e.target)) {
                selectedMarkId = m.id;
                updateMarkSelection();
                openProductModal(m);
            }
        });
        marksListEl.appendChild(item);
    });
}

/* ------------------------- ZOOMING ------------------------- */
function setScale(scale) {
    imageScale = Math.max(0.3, Math.min(3, scale));

    const img = previewImage;
    const containerRect = imgContainer.getBoundingClientRect();
    const imgAspect = img.naturalWidth / img.naturalHeight;
    const containerAspect = containerRect.width / containerRect.height;

    let displayWidth, displayHeight;
    if (imgAspect > containerAspect) {
        displayWidth = containerRect.width;
        displayHeight = containerRect.width / imgAspect;
    } else {
        displayHeight = containerRect.height;
        displayWidth = containerRect.height * imgAspect;
    }

    imageDisplayWidth = displayWidth * imageScale;
    imageDisplayHeight = displayHeight * imageScale;

    imgInner.style.transform = `scale(${imageScale})`;

    requestAnimationFrame(() => {
        updateImageDimensions();
    });
}

imgContainer.addEventListener('wheel', (e) => {
    if (!e.ctrlKey) return;
    e.preventDefault();
    const delta = -e.deltaY / 500;
    setScale(imageScale + delta);
});

let pinchStartDist = 0, pinchStartScale = 1;
imgContainer.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
        e.preventDefault();
        pinchStartDist = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY
        );
        pinchStartScale = imageScale;
    }
});

imgContainer.addEventListener('touchmove', (e) => {
    if (e.touches.length === 2) {
        e.preventDefault();
        const d = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY
        );
        const ratio = d / pinchStartDist;
        setScale(pinchStartScale * ratio);
    }
});

document.getElementById('zoomReset').addEventListener('click', () => {
    setScale(1);
});

imgContainer.addEventListener('click', (e) => {
    if (!e.target.closest('.mark') && !e.target.closest('.wire') && !e.target.closest('.draggable-point')) {
        selectedMarkId = null;
        updateMarkSelection();

        if (!isWireMode) {
            resetWireSelection();
        }
    }
});

function clearWireSelection() {
    isWireMode = false;
    currentWireType = null;

    wireStartMark = null;
    wireEndMark = null;
    wirePoints = [];
    selectedWire = null;

    document.querySelectorAll('.draggable-point').forEach(el => el.remove());

    const tempWire = document.querySelector('.wire-preview');
    if (tempWire) {
        tempWire.remove();
    }

    updateWireSelectionLabels();
    updatePointsList();

    document.querySelectorAll('.tab-btn[data-name^="KNX_WIRE"], .tab-btn[data-name^="PHASE_WIRE"], .tab-btn[data-name^="NEUTRAL_WIRE"]').forEach(btn => {
        btn.classList.remove('active');
    });

    wires.forEach(wire => {
        if (wire.element && wire.element.path) {
            wire.element.path.setAttribute('stroke-width', '4');
        }
    });

    const wireEditControls = document.querySelector('.wire-edit-controls');
    if (wireEditControls) {
        wireEditControls.remove();
    }

    hideWireControls();

    showNotification('Wire selection cleared', 'info');
}

/* ------------------------- INIT ------------------------- */
document.addEventListener('DOMContentLoaded', function () {
    loadFloorPlanImage();
    buildList();

    if (previewImage.complete) {
        updateImageDimensions();
    } else {
        previewImage.addEventListener('load', updateImageDimensions);
    }

    const firstKey = PRODUCT_ORDER[0] || Object.keys(productData)[0];
    selectProduct(firstKey);
});

/* ------------------------- UTILITY FUNCTIONS ------------------------- */
function showNotification(message, type = 'info') {
    const existingNotification = document.querySelector('.pdf-notification');
    if (existingNotification) {
        existingNotification.remove();
    }

    const notification = document.createElement('div');
    notification.className = `pdf-notification pdf-notification-${type}`;
    notification.innerHTML = `
            <span class="pdf-notification-icon">${type === 'success' ? 'âœ“' : 'âš '}</span>
            <span class="pdf-notification-text">${message}</span>
        `;

    notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            font-weight: 500;
            animation: slideInRight 0.3s ease;
        `;

    document.body.appendChild(notification);

    setTimeout(() => {
        if (notification.parentNode) {
            notification.style.animation = 'slideOutRight 0.3s ease';
            setTimeout(() => notification.remove(), 300);
        }
    }, 5000);
}

const style = document.createElement('style');
style.textContent = `
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
        
        .pdf-notification-icon {
            font-weight: bold;
            font-size: 16px;
        }
        
        .draggable-point {
            transition: all 0.2s ease;
        }
        
        .draggable-point:hover {
            transform: scale(1.3);
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        }
        
        .draggable-point.dragging {
            transform: scale(1.4);
            box-shadow: 0 6px 12px rgba(0,0,0,0.5);
            cursor: grabbing;
        }
        
        .form-control {
            width: 100%;
            padding: 10px 12px;
            border-radius: 8px;
            border: 2px solid #e8eaed;
            background: #ffffff;
            font-size: 13px;
            color: #202124;
            transition: all 0.2s;
        }
        
        .form-control:hover {
            border-color: #2196F3;
        }
        
        .form-control:focus {
            outline: none;
            border-color: #2196F3;
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
        }
    `;
document.head.appendChild(style);

/* ------------------------- BRAND ENHANCEMENT ------------------------- */
function enhanceProductDataWithBrands() {
    const brands = {
        "DOOR LOCK": "LocPro",
        "PROCESSOR": "LUMI",
        "LUMI GLASS SERIES": "LUMI",
        "ESCULT SERIES": "Escult",
        "WALL MOUNT DISPLAY": "LUMI",
        "TACTILE HEXA SERIES": "LUMI",
        "DUO-QUAD SERIES": "LUMI",
        "DOMOGENIE GLASS LITE SERIES": "Domogenie",
        "TREMBLAY SOUNDS": "Tremblay",
        "Z-WAVE RELAY": "LUMI",
        "CURTAIN MOTORS": "LUMI",
        "SENSORS": "Big Sense",
        "AUTOMATION DISTRIBUTION BOX": "DB",
        "NETWORK DISTRIBUTION BOX": "DB"
    };

    for (const [category, brand] of Object.entries(brands)) {
        if (productData[category]) {
            if (!productData[category].isDBBox) {
                productData[category].brand = brand;
            }
            if (productData[category].subProducts) {
                for (const subProduct of Object.values(productData[category].subProducts)) {
                    subProduct.brand = brand;
                }
            }
        }
    }
}

enhanceProductDataWithBrands();

/* ------------------------- PDF EXPORT FUNCTIONALITY ------------------------- */
document.getElementById('downloadPdfBtn').addEventListener('click', async function () {
    try {
        const btn = this;
        const originalText = btn.innerHTML;
        btn.innerHTML = '<span class="material-icons" style="font-size: 16px; margin-right: 8px;">hourglass_empty</span> Generating PDF...';
        btn.disabled = true;

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
            orientation: 'portrait',
            unit: 'mm',
            format: 'a4'
        });

        doc.setProperties({
            title: 'Home Automation Configuration',
            subject: 'Product Configuration Summary',
            creator: 'Automation Configurator'
        });

        doc.setFontSize(20);
        doc.setTextColor(40, 40, 40);
        doc.text('Automation Design Suite', 105, 20, { align: 'center' });

        doc.setFontSize(10);
        doc.setTextColor(100, 100, 100);
        const currentDate = new Date().toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
        doc.text(`Generated on: ${currentDate}`, 105, 28, { align: 'center' });

        let yPosition = 40;

        try {
            const screenshot = await captureFloorPlanScreenshot();
            if (screenshot) {
                const pageWidth = doc.internal.pageSize.getWidth();
                const margin = 20;
                const imgWidth = pageWidth - (2 * margin);

                const tempImg = new Image();
                tempImg.src = screenshot;
                await new Promise((resolve) => {
                    tempImg.onload = () => {
                        const aspectRatio = tempImg.height / tempImg.width;
                        const imgHeight = imgWidth * aspectRatio;

                        doc.addImage(screenshot, 'PNG', margin, yPosition, imgWidth, imgHeight);

                        doc.setFontSize(9);
                        doc.setTextColor(100, 100, 100);
                        doc.text('Floor Plan with Product Labels', 105, yPosition + imgHeight + 5, { align: 'center' });
                        yPosition = yPosition + imgHeight + 15;

                        resolve();
                    };
                    tempImg.onerror = resolve;
                });
            }
        } catch (imgError) {
            console.warn('Could not capture floor plan:', imgError);
            doc.setFontSize(12);
            doc.setTextColor(150, 150, 150);
            doc.text('Floor plan image not available', 105, 80, { align: 'center' });
            yPosition = 100;
        }

        doc.setFontSize(8);
        doc.setTextColor(150, 150, 150);
        doc.text('Page 1 of 2', doc.internal.pageSize.getWidth() - 20, doc.internal.pageSize.getHeight() - 10, { align: 'right' });

        doc.addPage();
        yPosition = 30;

        doc.setFontSize(20);
        doc.setTextColor(40, 40, 40);
        doc.text('Product Configuration Summary', 105, yPosition, { align: 'center' });
        yPosition += 10;

        doc.setFontSize(10);
        doc.setTextColor(100, 100, 100);
        doc.text(`Generated on: ${currentDate}`, 105, yPosition, { align: 'center' });
        yPosition += 15;

        const tables = generateProductTable();
        const hasDBBoxes = tables.dbBoxes.length > 0;
        const hasMainProducts = tables.mainProducts.length > 0;

        if (hasDBBoxes) {
            doc.setFontSize(14);
            doc.setTextColor(26, 115, 232);
            doc.text('Distribution Boxes', 20, yPosition);
            yPosition += 8;

            const dbTableData = tables.dbBoxes.map(item => [
                item.label,
                item.category,
                item.brand,
                item.size,
                item.model,
                item.quantity.toString()
            ]);

            doc.autoTable({
                startY: yPosition,
                head: [['Label', 'Type', 'Brand', 'Size (ft)', 'Model', 'Qty']],
                body: dbTableData,
                theme: 'grid',
                headStyles: {
                    fillColor: [33, 150, 243],
                    textColor: 255,
                    fontStyle: 'bold',
                    halign: 'center'
                },
                styles: {
                    fontSize: 8,
                    cellPadding: 3,
                    overflow: 'linebreak',
                    halign: 'center',
                    minCellHeight: 6
                },
                columnStyles: {
                    0: { cellWidth: 15, halign: 'center' },
                    1: { cellWidth: 30, halign: 'center' },
                    2: { cellWidth: 30, halign: 'center' },
                    3: { cellWidth: 20, halign: 'center' },
                    4: { cellWidth: 60, halign: 'left' },
                    5: { cellWidth: 15, halign: 'center' }
                },
                margin: { left: 15 }
            });

            yPosition = doc.lastAutoTable.finalY + 15;
        }

        if (hasMainProducts) {
            if (hasDBBoxes) {
                doc.setFontSize(14);
                doc.setTextColor(26, 115, 232);
                doc.text('Automation Products', 20, yPosition);
                yPosition += 8;
            }

            const mainTableData = tables.mainProducts.map(item => [
                item.label,
                item.category,
                item.brand,
                item.model,
                item.quantity.toString()
            ]);

            doc.autoTable({
                startY: yPosition,
                head: [['Label', 'Category', 'Brand', 'Model', 'Qty']],
                body: mainTableData,
                theme: 'grid',
                headStyles: {
                    fillColor: [76, 175, 80],
                    textColor: 255,
                    fontStyle: 'bold',
                    halign: 'center'
                },
                styles: {
                    fontSize: 8,
                    cellPadding: 3,
                    overflow: 'linebreak',
                    halign: 'center',
                    minCellHeight: 6
                },
                columnStyles: {
                    0: { cellWidth: 15, halign: 'center' },
                    1: { cellWidth: 40, halign: 'center' },
                    2: { cellWidth: 30, halign: 'center' },
                    3: { cellWidth: 80, halign: 'left' },
                    4: { cellWidth: 15, halign: 'center' }
                },
                margin: { left: 15 }
            });

            yPosition = doc.lastAutoTable.finalY + 10;
        }

        const totalDBBoxes = tables.dbBoxes.reduce((sum, item) => sum + item.quantity, 0);
        const totalMainProducts = tables.mainProducts.reduce((sum, item) => sum + item.quantity, 0);
        const totalProducts = totalDBBoxes + totalMainProducts;

        if (hasDBBoxes || hasMainProducts) {
            doc.setFontSize(10);
            doc.setTextColor(100, 100, 100);
            let summaryText = `Total Items: ${totalProducts}`;
            if (hasDBBoxes) summaryText += ` | DB Boxes: ${totalDBBoxes}`;
            if (hasMainProducts) summaryText += ` | Automation Products: ${totalMainProducts}`;

            doc.text(summaryText, 105, doc.internal.pageSize.getHeight() - 20, { align: 'center' });
        } else {
            doc.setFontSize(16);
            doc.setTextColor(100, 100, 100);
            doc.text('No Products Configured', 105, 80, { align: 'center' });
            doc.setFontSize(12);
            doc.text('Add products to the floor plan to generate a summary.', 105, 95, { align: 'center' });
        }

        doc.setFontSize(8);
        doc.setTextColor(150, 150, 150);
        doc.text(`Page 2 of 2`, 105, doc.internal.pageSize.getHeight() - 10, { align: 'center' });

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0];
        doc.save(`home-automation-configuration-${timestamp}.pdf`);

        showNotification('PDF generated successfully!', 'success');

    } catch (error) {
        console.error('PDF generation error:', error);
        showNotification('Error generating PDF: ' + error.message, 'error');
    } finally {
        const btn = document.getElementById('downloadPdfBtn');
        btn.innerHTML = '<span class="material-icons" style="font-size: 16px; margin-right: 8px;">download</span> DOWNLOAD CONFIGURATOR PDF';
        btn.disabled = false;
    }
});

async function captureFloorPlanScreenshot() {
    try {
        const imageContainer = document.querySelector('.img-container');

        const notifications = document.querySelectorAll('.pdf-notification');
        notifications.forEach(n => n.style.visibility = 'hidden');

        const canvas = await html2canvas(imageContainer, {
            backgroundColor: '#ffffff',
            scale: 1,
            useCORS: true,
            logging: false,
            allowTaint: true,
            imageTimeout: 15000,
            onclone: function (clonedDoc) {
                const images = clonedDoc.querySelectorAll('img');
                images.forEach(img => {
                    if (img.complete) return;
                    img.onload = function () {
                        console.log('Image loaded in clone');
                    };
                });
            }
        });

        notifications.forEach(n => n.style.visibility = 'visible');

        return canvas.toDataURL('image/png');
    } catch (error) {
        console.error('Screenshot capture error:', error);

        const canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 600;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#f8f9fa';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#5f6368';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Floor Plan Image Not Available', canvas.width / 2, canvas.height / 2);
        ctx.font = '12px Arial';
        ctx.fillText('Please check console for errors', canvas.width / 2, canvas.height / 2 + 20);

        return canvas.toDataURL('image/png');
    }
}

function generateProductTable() {
    if (marks.length === 0) return { mainProducts: [], dbBoxes: [] };

    const productMap = new Map();
    const dbBoxesTable = [];

    marks.forEach(mark => {
        const key = mark.seriesLabel;
        const category = mark.categoryName || 'Unknown';
        let model = mark.modelName || 'Unknown';
        let brand = 'LUMI';

        if (mark.categoryName && productData[mark.categoryName]) {
            brand = productData[mark.categoryName].brand || brand;
        }

        if (mark.isDBBox) {
            dbBoxesTable.push({
                label: key,
                category: category,
                brand: mark.brand || 'Not specified',
                size: mark.sizeFt || 'Not specified',
                model: model,
                quantity: 1
            });
            return;
        }

        if (category === 'Z-WAVE RELAY' && mark.relayItems && mark.relayItems.length > 0) {
            mark.relayItems.forEach(relayItem => {
                const relayKey = `${key}-${relayItem.name}`;
                if (!productMap.has(relayKey)) {
                    productMap.set(relayKey, {
                        label: key,
                        category: 'Relay Module',
                        brand: 'LUMI',
                        model: relayItem.name,
                        quantity: relayItem.quantity
                    });
                } else {
                    productMap.get(relayKey).quantity += relayItem.quantity;
                }
            });
            return;
        }

        if (!productMap.has(key)) {
            productMap.set(key, {
                label: key,
                category: category,
                brand: brand,
                model: model,
                quantity: 1
            });
        } else {
            productMap.get(key).quantity += 1;
        }
    });

    const mainProducts = Array.from(productMap.values())
        .sort((a, b) => {
            return a.label.localeCompare(b.label);
        });

    return {
        mainProducts: mainProducts,
        dbBoxes: dbBoxesTable.sort((a, b) => a.label.localeCompare(b.label))
    };
}
/* ------------------------- PROJECT SAVE/LOAD FUNCTIONS ------------------------- */

// Add event listeners for save/load buttons
document.addEventListener('DOMContentLoaded', function () {
    // Add event listeners for project management buttons
    const saveProjectBtn = document.getElementById('saveProjectBtn');
    const loadProjectBtn = document.getElementById('loadProjectBtn');
    const newProjectBtn = document.getElementById('newProjectBtn');
    const projectFileInput = document.getElementById('projectFileInput');

    if (saveProjectBtn) {
        saveProjectBtn.addEventListener('click', saveProject);
    }

    if (loadProjectBtn) {
        loadProjectBtn.addEventListener('click', () => {
            projectFileInput.click();
        });
    }

    if (newProjectBtn) {
        newProjectBtn.addEventListener('click', createNewProject);
    }

    if (projectFileInput) {
        projectFileInput.addEventListener('change', loadProjectFromFile);
    }
});

// Save current project to a JSON file
function saveProject() {
    try {
        const btn = document.getElementById('saveProjectBtn');
        const originalText = btn.innerHTML;
        btn.innerHTML = '<span class="material-icons" style="font-size: 16px; margin-right: 8px;">hourglass_empty</span> Saving...';
        btn.disabled = true;

        // Build project data object
        const projectData = {
            version: '2.0',
            timestamp: new Date().toISOString(),
            floorPlanImage: previewImage.src,
            marks: marks.map(mark => ({
                x: mark.x,
                y: mark.y,
                size: mark.size,
                shape: mark.shape,
                seriesCode: mark.seriesCode,
                seriesLabel: mark.seriesLabel,
                categoryName: mark.categoryName,
                modelName: mark.modelName,
                desc: mark.desc,
                features: mark.features,
                imageSrc: mark.imageSrc,
                relayItems: mark.relayItems,
                isDBBox: mark.isDBBox,
                brand: mark.brand,
                sizeFt: mark.sizeFt,
                // Include product reference data
                productKey: currentProduct,
                subProductKey: currentSubProduct
            })),
            wires: wires.map(wire => ({
                id: wire.id,
                startMarkLabel: wire.startMark.seriesLabel,
                endMarkLabel: wire.endMark.seriesLabel,
                wireType: wire.wireType,
                mode: wire.mode,
                curveValue: wire.curveValue,
                points: wire.points.map(p => ({ x: p.x, y: p.y })),
                color: wire.color
            })),
            relayState: relayState,
            lastRelaySelectionLabel: lastRelaySelectionLabel,
            currentProduct: currentProduct,
            currentSubProduct: currentSubProduct,
            seriesCounters: seriesCounters,
            markCounter: markCounter,
            imageScale: imageScale,
            // Save DB box specifications from productData
            dbBoxSpecs: Object.keys(productData)
                .filter(key => productData[key].isDBBox)
                .reduce((specs, key) => {
                    specs[key] = {
                        brand: productData[key].brand || '',
                        size: productData[key].size || ''
                    };
                    return specs;
                }, {})
        };

        // Convert to JSON string
        const jsonString = JSON.stringify(projectData, null, 2);

        // Create blob and download
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `floor-plan-configuration-${new Date().toISOString().split('T')[0]}.dmp`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        showNotification('Project saved successfully!', 'success');

        setTimeout(() => {
            btn.innerHTML = originalText;
            btn.disabled = false;
        }, 1000);

    } catch (error) {
        console.error('Save error:', error);
        showNotification('Error saving project: ' + error.message, 'error');

        const btn = document.getElementById('saveProjectBtn');
        btn.innerHTML = '<span class="material-icons" style="font-size: 16px; margin-right: 8px;">save</span> SAVE PROJECT';
        btn.disabled = false;
    }
}

// Load project from file
function loadProjectFromFile(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function (e) {
        try {
            const projectData = JSON.parse(e.target.result);
            loadProject(projectData);
            showNotification('Project loaded successfully!', 'success');
        } catch (error) {
            console.error('Load error:', error);
            showNotification('Error loading project: Invalid file format', 'error');
        }

        // Reset file input
        event.target.value = '';
    };

    reader.readAsText(file);
}

// Load project from data object
function loadProject(projectData) {
    // Validate project data
    if (!projectData.version || !projectData.marks || !projectData.wires) {
        showNotification('Invalid project file format', 'error');
        return;
    }

    // Clear current project
    clearAllMarksAndWires();

    // Reset counters
    markCounter = 0;
    Object.keys(seriesCounters).forEach(key => delete seriesCounters[key]);

    // Load floor plan image
    if (projectData.floorPlanImage) {
        previewImage.src = projectData.floorPlanImage;
        previewImage.onload = function () {
            // Load the rest after image loads
            loadProjectData(projectData);
        };
    } else {
        loadProjectData(projectData);
    }
}

// Load project data after image is ready
function loadProjectData(projectData) {
    // Restore image scale
    if (projectData.imageScale) {
        setScale(projectData.imageScale);
    }

    // Restore DB box specifications
    if (projectData.dbBoxSpecs) {
        Object.keys(projectData.dbBoxSpecs).forEach(key => {
            if (productData[key]) {
                productData[key].brand = projectData.dbBoxSpecs[key].brand;
                productData[key].size = projectData.dbBoxSpecs[key].size;
            }
        });
    }

    // Create a mapping from seriesLabel to mark object for wire restoration
    const markMap = new Map();

    // Restore marks
    projectData.marks.forEach(savedMark => {
        // Find the actual product data
        let productDataForMark;
        if (savedMark.productKey && productData[savedMark.productKey]) {
            if (savedMark.subProductKey && productData[savedMark.productKey].subProducts) {
                productDataForMark = productData[savedMark.productKey].subProducts[savedMark.subProductKey];
            } else {
                productDataForMark = productData[savedMark.productKey];
            }
        }

        // Create mark object
        const mark = {
            id: 'mark-' + (++markCounter),
            x: savedMark.x,
            y: savedMark.y,
            size: savedMark.size,
            shape: savedMark.shape || 'circle',
            seriesCode: savedMark.seriesCode,
            seriesLabel: savedMark.seriesLabel,
            categoryName: savedMark.categoryName,
            modelName: savedMark.modelName,
            desc: savedMark.desc,
            features: savedMark.features || [],
            imageSrc: savedMark.imageSrc,
            relayItems: savedMark.relayItems || [],
            isDBBox: savedMark.isDBBox || false,
            brand: savedMark.brand || '',
            sizeFt: savedMark.sizeFt || ''
        };

        // Update series counter
        if (!seriesCounters[mark.seriesCode]) {
            seriesCounters[mark.seriesCode] = 0;
        }
        const num = parseInt(mark.seriesLabel.substring(mark.seriesCode.length)) || 0;
        seriesCounters[mark.seriesCode] = Math.max(seriesCounters[mark.seriesCode], num);

        // Create DOM element
        const el = document.createElement('div');
        el.className = 'mark ' + mark.shape;
        el.dataset.id = mark.id;
        el.dataset.size = mark.size;
        el.dataset.shape = mark.shape;

        const badge = document.createElement('div');
        badge.className = 'label-badge';
        badge.textContent = mark.seriesLabel;
        el.appendChild(badge);

        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip';

        const tooltipContent = document.createElement('div');
        tooltipContent.className = 'tooltip-content';

        const tooltipTitle = document.createElement('div');
        tooltipTitle.className = 'tooltip-title';
        tooltipTitle.textContent = mark.categoryName || 'Product';

        const tooltipModel = document.createElement('div');
        tooltipModel.className = 'tooltip-model';
        tooltipModel.textContent = mark.modelName || 'â€”';

        tooltipContent.appendChild(tooltipTitle);
        tooltipContent.appendChild(tooltipModel);
        tooltip.appendChild(tooltipContent);
        el.appendChild(tooltip);

        imgInner.appendChild(el);

        // Add event listeners for dragging
        let dragging = false;
        let startX = 0, startY = 0;
        let startMarkX = 0, startMarkY = 0;
        let dragStarted = false;

        function onPointerDown(ev) {
            ev.stopPropagation();
            ev.preventDefault();
            el.setPointerCapture(ev.pointerId);
            dragging = true;
            dragStarted = false;
            startX = ev.clientX;
            startY = ev.clientY;
            startMarkX = mark.x;
            startMarkY = mark.y;
            selectedMarkId = mark.id;
            updateMarkSelection();
            el.classList.add('selected');
        }

        function onPointerMove(ev) {
            if (!dragging) return;

            const dx = ev.clientX - startX;
            const dy = ev.clientY - startY;

            if (!dragStarted && (Math.abs(dx) > 3 || Math.abs(dy) > 3)) {
                dragStarted = true;
            }

            if (!dragStarted) return;

            ev.preventDefault();
            ev.stopPropagation();

            const transform = getImageTransform();
            if (!transform || !imageNaturalWidth || !imageNaturalHeight) return;

            const imgRect = previewImage.getBoundingClientRect();
            const scaleX = imageNaturalWidth / imgRect.width;
            const scaleY = imageNaturalHeight / imgRect.height;

            const imageDx = dx * scaleX;
            const imageDy = dy * scaleY;

            let newX = startMarkX + imageDx;
            let newY = startMarkY + imageDy;

            newX = Math.max(0, Math.min(imageNaturalWidth - mark.size, newX));
            newY = Math.max(0, Math.min(imageNaturalHeight - mark.size, newY));

            mark.x = newX;
            mark.y = newY;

            updateMarkPosition(mark);
            updateAllWires();
        }

        function onPointerUp(ev) {
            if (dragging) {
                dragging = false;
                dragStarted = false;
                try {
                    el.releasePointerCapture(ev.pointerId);
                } catch (e) { }
                el.classList.remove('selected');

                if (!dragStarted) {
                    selectedMarkId = mark.id;
                    updateMarkSelection();
                    openProductModal(mark);
                }
            }
        }

        el.addEventListener('pointerdown', onPointerDown);
        el.addEventListener('mouseenter', () => orientTooltip(mark));
        document.addEventListener('pointermove', onPointerMove);
        document.addEventListener('pointerup', onPointerUp);

        // Click to open modal
        el.addEventListener('click', function (e) {
            if (!dragStarted && !isWireMode) {
                selectedMarkId = mark.id;
                updateMarkSelection();
                openProductModal(mark);
            }
        });

        // Store reference
        mark.el = el;
        mark.tooltip = tooltip;
        marks.push(mark);
        markMap.set(mark.seriesLabel, mark);
    });

    // Update marks display
    updateAllMarks();
    renderMarksList();

    // Restore wires
    projectData.wires.forEach(savedWire => {
        const startMark = markMap.get(savedWire.startMarkLabel);
        const endMark = markMap.get(savedWire.endMarkLabel);

        if (!startMark || !endMark) {
            console.warn('Could not find marks for wire:', savedWire.startMarkLabel, savedWire.endMarkLabel);
            return;
        }

        // Set current wire type for creation
        const originalWireType = currentWireType;
        currentWireType = savedWire.wireType;

        let wireElement;
        if (savedWire.mode === 'curve') {
            wireElement = createWireElement(startMark, endMark, savedWire.curveValue, false);
        } else {
            // For points mode, create wire with points
            wireElement = createWireElementWithPoints(startMark, endMark, savedWire.points, false);
        }

        // Restore original wire type
        currentWireType = originalWireType;

        if (!wireElement) return;

        const wire = {
            id: savedWire.id || `wire-${Date.now()}`,
            startMark: startMark,
            endMark: endMark,
            element: wireElement,
            mode: savedWire.mode,
            curveValue: savedWire.curveValue,
            points: savedWire.points || [],
            wireType: savedWire.wireType,
            color: savedWire.color || getWireTypeInfo(savedWire.wireType).color
        };

        wires.push(wire);
    });

    // Restore relay state
    if (projectData.relayState) {
        Object.assign(relayState, projectData.relayState);
        lastRelaySelectionLabel = projectData.lastRelaySelectionLabel || '';
    }

    // Restore current product selection
    if (projectData.currentProduct) {
        setTimeout(() => {
            selectProduct(projectData.currentProduct, projectData.currentSubProduct);
            if (projectData.currentProduct === 'Z-WAVE RELAY') {
                updateRelayOverlay();
            }
        }, 100);
    }

    // Update wires list if wire controls are visible
    if (currentWireType) {
        updateWiresList();
    }

    showNotification(`Project loaded: ${projectData.marks.length} marks, ${projectData.wires.length} wires`, 'success');
}


// Helper function to create wire element with points
function createWireElementWithPoints(startMark, endMark, points, isPreview = false) {
    const transform = getImageTransform();
    if (!transform) return null;

    const startX = startMark.x * transform.scaleX + transform.imgOffsetX + (startMark.size * transform.scaleX / 2);
    const startY = startMark.y * transform.scaleY + transform.imgOffsetY + (startMark.size * transform.scaleY / 2);
    const endX = endMark.x * transform.scaleX + transform.imgOffsetX + (endMark.size * transform.scaleX / 2);
    const endY = endMark.y * transform.scaleY + transform.imgOffsetY + (endMark.size * transform.scaleY / 2);

    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("class", isPreview ? "wire-preview" : "wire");
    svg.setAttribute("data-wire-type", currentWireType);
    svg.style.position = "absolute";
    svg.style.top = "0";
    svg.style.left = "0";
    svg.style.width = "100%";
    svg.style.height = "100%";
    svg.style.pointerEvents = isPreview ? "none" : "auto";
    svg.style.zIndex = isPreview ? "5" : "9";

    const wireTypeInfo = getWireTypeInfo(currentWireType);
    const wireColor = wireTypeInfo.color;

    let pathData = `M ${startX} ${startY}`;

    points.forEach(point => {
        const pointX = point.x * transform.scaleX + transform.imgOffsetX;
        const pointY = point.y * transform.scaleY + transform.imgOffsetY;
        pathData += ` L ${pointX} ${pointY}`;
    });

    pathData += ` L ${endX} ${endY}`;

    const path = document.createElementNS(svgNS, "path");
    path.setAttribute("d", pathData);
    path.setAttribute("stroke", isPreview ? wireColor + "80" : wireColor);
    path.setAttribute("stroke-width", isPreview ? "3" : "4");
    path.setAttribute("stroke-linecap", "round");
    path.setAttribute("stroke-linejoin", "round");
    path.setAttribute("fill", "none");
    path.setAttribute("stroke-dasharray", isPreview ? "5,5" : "none");

    if (!isPreview) {
        path.style.cursor = "pointer";
        path.addEventListener('click', function (e) {
            e.stopPropagation();
            selectWire(startMark, endMark, currentWireType);
        });

        makeWireDraggable(path, startMark, endMark);
    }

    svg.appendChild(path);

    const startCircle = document.createElementNS(svgNS, "circle");
    startCircle.setAttribute("cx", startX);
    startCircle.setAttribute("cy", startY);
    startCircle.setAttribute("r", "6");
    startCircle.setAttribute("fill", wireColor);
    startCircle.setAttribute("stroke", "#fff");
    startCircle.setAttribute("stroke-width", "2");

    const endCircle = document.createElementNS(svgNS, "circle");
    endCircle.setAttribute("cx", endX);
    endCircle.setAttribute("cy", endY);
    endCircle.setAttribute("r", "6");
    endCircle.setAttribute("fill", wireColor);
    endCircle.setAttribute("stroke", "#fff");
    endCircle.setAttribute("stroke-width", "2");

    svg.appendChild(startCircle);
    svg.appendChild(endCircle);

    imgInner.appendChild(svg);

    return {
        svg,
        path,
        startCircle,
        endCircle,
        startX, startY, endX, endY
    };
}