<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <!-- Add these before the closing </head> tag in panel.html -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>
    <!-- <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>

    <script src="./login/firebase-config.js"></script>

    <script src="./scripts/auth-check.js"></script> -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Premium Product Layout — 20/20/60 Split</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <style>
        :root {
            --left-width: 20%;
            --middle-width: 20%;
            --right-width: 60%;
            --panel-bg: #ffffff;
            --accent: #1a73e8;
            --accent-hover: #1557b0;
            --muted: #5f6368;
            --border: #e8eaed;
            --hover-bg: #f8f9fa;
            --shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
            --shadow-hover: 0 4px 6px rgba(0, 0, 0, 0.15), 0 2px 4px rgba(0, 0, 0, 0.12);
        }

        * {
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        body {
            margin: 0;
            background: #f5f6f8;
            color: #202124;
        }

        .container {
            display: flex;
            height: 100vh;
            gap: 0;
        }

        /* LEFT PANEL - Product List */
        .left-panel {
            width: var(--left-width);
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            border-right: 1px solid var(--border);
            background: #ffffff;
            box-shadow: 1px 0 3px rgba(0, 0, 0, 0.05);
        }

        .left-panel h2 {
            font-size: 16px;
            font-weight: 600;
            color: #202124;
            margin: 0 0 20px 0;
            padding-bottom: 12px;
            border-bottom: 2px solid var(--border);
            letter-spacing: -0.3px;
        }

        .list-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .tab-btn {
            background: #ffffff;
            border: 2px solid var(--border);
            padding: 14px 16px;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            min-height: 54px;
        }

        .tab-btn:hover {
            background: var(--hover-bg);
            border-color: var(--accent);
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        .tab-btn.active {
            background: linear-gradient(135deg, #e8f0fe 0%, #f1f5fe 100%);
            border-color: var(--accent);
            box-shadow: 0 2px 8px rgba(26, 115, 232, 0.15);
        }

        .tab-title {
            font-weight: 500;
            font-size: 14px;
            color: #202124;
            line-height: 1.4;
        }

        .tab-sub {
            font-size: 12px;
            color: var(--muted);
            margin-top: 2px;
        }

        /* MIDDLE PANEL - Product Details & Mark Controls */
        .middle-panel {
            width: var(--middle-width);
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            border-right: 1px solid var(--border);
            background: #ffffff;
            box-shadow: 1px 0 3px rgba(0, 0, 0, 0.05);
        }

        /* Product Image in Middle */
        .product-image-container {
            width: 100%;
            aspect-ratio: 1/1;
            margin-bottom: 20px;
            border-radius: 12px;
            overflow: hidden;
            background: #f0f2f5;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .product-image-container img {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: cover;
            background: #f0f2f5;
        }

        .detail-box {
            background: #ffffff;
            border: 1px solid var(--border);
            padding: 18px;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            margin-bottom: 20px;
        }

        .product-title {
            font-size: 17px;
            font-weight: 600;
            color: #1a73e8;
            margin: 0 0 10px 0;
            line-height: 1.3;
        }

        .product-desc {
            font-size: 13px;
            color: #5f6368;
            margin: 0 0 16px 0;
            line-height: 1.5;
        }

        .product-meta {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .meta-item {
            font-size: 11px;
            color: #5f6368;
            padding: 6px 10px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid var(--border);
            font-weight: 500;
        }

        /* Mark Controls Box */
        .mark-controls-box {
            background: #ffffff;
            border: 1px solid var(--border);
            padding: 18px;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .mark-controls-box h3 {
            font-size: 15px;
            font-weight: 600;
            color: #202124;
            margin: 0 0 16px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border);
        }

        /* Form Controls */
        .form-group {
            margin-bottom: 16px;
        }

        .form-row {
            display: flex;
            gap: 12px;
            align-items: flex-end;
            margin-bottom: 16px;
        }

        .form-row>div {
            flex: 1;
        }

        label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            color: #5f6368;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        select {
            width: 100%;
            padding: 10px 12px;
            border-radius: 8px;
            border: 2px solid var(--border);
            background: #ffffff;
            font-size: 13px;
            color: #202124;
            cursor: pointer;
            transition: all 0.2s;
        }

        select:hover {
            border-color: var(--accent);
        }

        select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(26, 115, 232, 0.1);
        }

        input[type=text] {
            width: 100%;
            padding: 10px 12px;
            border-radius: 8px;
            border: 2px solid var(--border);
            background: #ffffff;
            font-size: 13px;
            color: #202124;
            transition: all 0.2s;
        }

        input[type=text]:hover {
            border-color: var(--accent);
        }

        input[type=text]:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(26, 115, 232, 0.1);
        }

        /* Buttons */
        .btn {
            padding: 10px 16px;
            border-radius: 8px;
            border: 2px solid var(--border);
            background: #ffffff;
            color: #202124;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-height: 40px;
        }

        .btn:hover {
            background: var(--hover-bg);
            border-color: var(--accent);
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        .btn.primary {
            background: var(--accent);
            color: #ffffff;
            border-color: var(--accent);
            box-shadow: 0 2px 4px rgba(26, 115, 232, 0.3);
        }

        .btn.primary:hover {
            background: var(--accent-hover);
            box-shadow: 0 4px 8px rgba(26, 115, 232, 0.4);
            transform: translateY(-2px);
        }

        .btn.full-width {
            width: 100%;
        }

        /* Mark List */
        #marksList {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            max-height: 140px;
            overflow-y: auto;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .mark-item {
            padding: 8px 12px;
            border-radius: 6px;
            border: 2px solid var(--border);
            background: #ffffff;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            color: #202124;
            transition: all 0.2s;
            min-height: 32px;
            display: inline-flex;
            align-items: center;
        }

        .mark-item:hover {
            border-color: var(--accent);
            background: var(--hover-bg);
        }

        .mark-item.active {
            border-color: var(--accent);
            background: linear-gradient(135deg, #e8f0fe 0%, #f1f5fe 100%);
            box-shadow: 0 2px 4px rgba(26, 115, 232, 0.2);
        }

        .mark-item button {
            padding: 4px 6px;
            min-height: 24px;
            font-size: 11px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .mark-item:hover button {
            opacity: 1;
        }

        .mark-item button:hover {
            background: #ff4444;
            color: #ffffff;
            border-color: #ff4444;
        }

        /* RIGHT PANEL - Full Image Container */
        .right-panel {
            width: var(--right-width);
            padding: 0;
            overflow: hidden;
            background: #f8f9fa;
            position: relative;
        }

        .image-wrap {
            position: relative;
            width: 100%;
            height: 100%;
            background: #ffffff;
            overflow: hidden;
        }

        .img-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #f8f9fa;
            touch-action: none;
            position: relative;
        }

        .img-inner {
            transform-origin: center center;
            transition: transform 0.08s linear;
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .img-inner img {
            display: block;
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
            user-select: none;
            pointer-events: none;
            position: relative;
        }

        /* Modern Mark/Label Design */
        .mark {
            position: absolute;
            touch-action: none;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .mark .label-badge {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ffffff;
            font-weight: 700;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4),
                0 2px 4px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            border: 3px solid #ffffff;
            transition: all 0.2s;
            pointer-events: none;
            position: relative;
        }

        .mark .label-badge::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60%;
            height: 60%;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
        }

        .mark.circle .label-badge {
            border-radius: 50%;
        }

        .mark.square .label-badge {
            border-radius: 8px;
        }

        .mark:hover .label-badge {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.5),
                0 3px 6px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .mark.selected .label-badge {
            box-shadow: 0 0 0 4px rgba(26, 115, 232, 0.3),
                0 4px 12px rgba(102, 126, 234, 0.4),
                0 2px 4px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .mark .tooltip {
            position: absolute;
            background: rgba(32, 33, 36, 0.95);
            backdrop-filter: blur(10px);
            color: #ffffff;
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 12px;
            white-space: normal;
            word-break: keep-all;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: flex-start;
            z-index: 20;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            min-width: 120px;
            max-width: 260px;
        }

        .mark .tooltip img {
            width: 48px;
            height: 48px;
            object-fit: cover;
            border-radius: 6px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .mark .tooltip-content {
            display: flex;
            flex-direction: column;
        }

        .mark .tooltip-title {
            font-weight: 600;
            font-size: 12px;
            color: #ffffff;
            line-height: 1.3;
            white-space: nowrap;
        }

        .mark .tooltip-model {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.85);
            line-height: 1.4;
            white-space: nowrap;
        }

        .mark .tooltip-subtitle {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.8);
        }

        .mark:hover .tooltip {
            opacity: 1;
        }

        /* Features List */
        #pFeatures {
            font-size: 13px;
            color: #5f6368;
            padding-left: 20px;
            margin: 8px 0 0 0;
            line-height: 1.8;
        }

        #pFeatures li {
            margin-bottom: 6px;
        }

        .product-image-container {
            position: relative;
        }

        .product-image-overlay {
            position: absolute;
            inset: auto 12px 12px 12px;
            background: rgba(0, 0, 0, 0.65);
            color: #fff;
            padding: 10px 14px;
            border-radius: 10px;
            font-size: 12px;
            line-height: 1.5;
            display: none;
        }

        /* Relay controls */
        .relay-controls {
            background: #f8f9fa;
            border: 1px dashed var(--border);
            border-radius: 10px;
            padding: 16px;
            display: none;
        }

        .relay-controls h4 {
            margin: 0 0 12px 0;
            font-size: 13px;
            color: #202124;
            letter-spacing: 0.3px;
        }

        .relay-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .relay-option {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px 14px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: #fff;
        }

        .relay-option label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0;
            text-transform: none;
            letter-spacing: 0;
            color: #202124;
            font-weight: 500;
        }

        .relay-option input[type="number"] {
            width: 100%;
            padding: 6px 10px;
        }

        .relay-qty-row {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 11px;
            color: #5f6368;
            text-transform: uppercase;
            letter-spacing: 0.4px;
        }

        .relay-hint {
            font-size: 12px;
            color: var(--muted);
            margin-top: 12px;
        }

        /* Product modal */
        .product-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.55);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 24px;
            z-index: 200;
        }

        .product-modal.show {
            display: flex;
        }

        .product-modal__dialog {
            background: #ffffff;
            border-radius: 16px;
            max-width: 640px;
            width: 100%;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2);
            overflow: hidden;
        }

        .product-modal__header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 18px 24px 12px;
        }

        .product-modal__header h3 {
            margin: 0;
            font-size: 18px;
            color: #202124;
        }

        .product-modal__close {
            background: none;
            border: none;
            font-size: 22px;
            cursor: pointer;
            color: #5f6368;
        }

        .product-modal__body {
            display: flex;
            gap: 20px;
            padding: 0 24px 24px;
            flex-wrap: wrap;
        }

        .product-modal__image {
            flex: 1 1 220px;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid #e8eaed;
            background: #f8f9fa;
        }

        .product-modal__image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .product-modal__content {
            flex: 1 1 260px;
        }

        .product-modal__desc {
            font-size: 13px;
            color: #5f6368;
            margin: 0 0 12px 0;
            line-height: 1.5;
        }

        .product-modal__features {
            list-style: disc;
            padding-left: 18px;
            margin: 0;
            color: #202124;
            font-size: 13px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        /* Responsive */
        @media (max-width:800px) {
            .container {
                flex-direction: column
            }

            .left-panel {
                width: 100%;
                height: auto;
                max-height: 200px
            }

            .middle-panel {
                width: 100%;
                height: auto;
                max-height: 400px
            }

            .right-panel {
                width: 100%;
                height: 50vh
            }
        }

        /* Stylish device warning screen */
        #device-warning {
            display: none;
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #1a2533, #0d141c);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 999999;
            justify-content: center;
            align-items: center;
            padding: 20px;
            animation: fadeIn 0.5s ease forwards;
        }

        .warning-box {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 35px 40px;
            border-radius: 16px;
            text-align: center;
            max-width: 350px;
            color: #ffffff;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.6s ease forwards;
        }

        .warning-icon {
            font-size: 50px;
            margin-bottom: 15px;
            animation: pulse 1.3s infinite ease-in-out;
        }

        .warning-box h2 {
            font-size: 22px;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .warning-box p {
            font-size: 15px;
            opacity: 0.9;
        }

        /* Responsive rule to hide app below 850px */
        @media (max-width: 850px) {
            .container {
                display: none !important;
            }

            #device-warning {
                display: flex !important;
            }
        }
    </style>
</head>

<body>
    <div id="device-warning">
        <div class="warning-box">
            <div class="warning-icon">⚠️</div>
            <h2>Please Use a Laptop or Desktop</h2>
            <p>This 2D Floor Planner works only on larger screens.</p>
        </div>
    </div>

    <div class="container">
        <!-- LEFT: Product List (20%) -->
        <div class="left-panel" id="listSidebar">
            <h2>Products</h2>
            <div class="list-grid" id="productList">
                <!-- JS will populate tabs here -->
            </div>
        </div>

        <!-- MIDDLE: Product Details & Mark Controls (20%) -->
        <div class="middle-panel">
            <!-- Product Image -->
            <div class="product-image-container">
                <img id="productImage" src="" alt="Product Image">
                <div id="productImageOverlay" class="product-image-overlay"></div>
            </div>

            <div class="detail-box" id="productDetails">
                <div class="product-title" id="pTitle">Select a product</div>
                <div class="product-desc" id="pDesc">Click any item on the left to see its details. For composite models
                    expand the model list and select one.</div>
                <div class="product-meta" id="pMeta"></div>

                <div id="featuresSection" style="margin-top:16px">
                    <label
                        style="display:block;margin-bottom:8px;font-size:12px;font-weight:500;color:#5f6368;text-transform:uppercase;letter-spacing:0.5px">Product
                        Features</label>
                    <ul id="pFeatures"
                        style="font-size:13px;color:#5f6368;padding-left:20px;margin:8px 0 0 0;line-height:1.8">
                        <li>Select a product to see its features</li>
                    </ul>
                </div>

                <div id="relayControls" class="relay-controls">
                    <h4>Select Relay Modules</h4>
                    <div id="relayOptionsList" class="relay-options"></div>
                    <div class="relay-hint">Choose one or more relay modules and set quantity before adding a label.
                    </div>
                </div>
            </div>

            <!-- Mark Controls Box -->
            <div class="mark-controls-box">
                <h3>Mark Controls</h3>

                <div class="form-row">
                    <div class="form-group">
                        <label>Shape</label>
                        <select id="markShape">
                            <option value="circle">Circle</option>
                            <option value="square">Square</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Size (%)</label>
                        <input type="text" id="markSizeText" value="5" placeholder="e.g. 5">
                    </div>
                </div>

                <div class="form-group">
                    <button id="addMarkBtn" class="btn primary full-width">Add Mark</button>
                </div>

                <div class="form-group">
                    <label>Marks (click to select)</label>
                    <div id="marksList"></div>
                </div>

                <div class="form-group" style="margin-bottom:0">
                    <button id="zoomReset" class="btn full-width">Reset Zoom</button>
                </div>

                <div style="margin-top:12px;color:var(--muted);font-size:11px;text-align:center">
                    Use <b>Ctrl + Wheel</b> to zoom
                </div>
                <!-- Add this right after the mark controls box in panel.html -->
                <div class="mark-controls-box" style="margin-top: 20px;">
                    <h3>Export Configuration</h3>
                    <div class="form-group">
                        <button id="downloadPdfBtn" class="btn primary full-width">
                            <span class="material-icons" style="font-size: 16px; margin-right: 8px;">download</span>
                            DOWNLOAD CONFIGURATOR PDF
                        </button>
                    </div>
                    <div style="margin-top: 12px; color: var(--muted); font-size: 11px; text-align: center;">
                        Generates PDF with floor plan and product summary
                    </div>
                </div>
            </div>
        </div>

        <!-- RIGHT: Full Image Container (60%) -->
        <div class="right-panel">
            <div class="image-wrap">
                <div class="img-container" id="imgContainer">
                    <div class="img-inner" id="imgInner">
                        <img id="previewImage" src="" alt="Floor plan preview">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Product Modal -->
    <div id="productModal" class="product-modal">
        <div class="product-modal__dialog">
            <div class="product-modal__header">
                <h3 id="modalProductTitle">Product</h3>
                <button id="modalCloseBtn" class="product-modal__close">&times;</button>
            </div>
            <div class="product-modal__body">
                <div class="product-modal__image">
                    <img id="modalProductImage" src="" alt="Selected product preview">
                </div>
                <div class="product-modal__content">
                    <p id="modalProductDesc" class="product-modal__desc"></p>
                    <ul id="modalProductFeatures" class="product-modal__features"></ul>
                </div>
            </div>
        </div>
    </div>
<script>
    /* ------------------------- PRODUCT DATA ------------------------- */
    const productData = {
        "DOOR LOCK": {
            title: "Door Lock",
            desc: "Smart door locks with multiple access methods.",
            subProducts: {
                "DS811": {
                    title: "DS811",
                    desc: "Smart door lock with multiple access methods",
                    img: "./images/doorlock/7.png",
                    features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App", "Doorbell"]
                },
                "DG10S": {
                    title: "DG10S",
                    desc: "Advanced smart door lock",
                    img: "./images/doorlock/8.png",
                    features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App", "Doorbell"]
                },
                "DMSGSERIES": {
                    title: "DMSGSERIES",
                    desc: "Premium smart door lock series",
                    img: "./images/doorlock/9.png",
                    features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App"]
                },
                "DS605": {
                    title: "DS605",
                    desc: "Compact smart door lock",
                    img: "./images/doorlock/10.png",
                    features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App", "Doorbell"]
                },
                "DS923MAX": {
                    title: "DS923MAX",
                    desc: "Maximum security door lock",
                    img: "./images/doorlock/11.png",
                    features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App", "Doorbell"]
                },
                "DMFASL53": {
                    title: "DMFASL53",
                    desc: "Advanced fingerprint door lock",
                    img: "./images/doorlock/12.png",
                    features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App", "Doorbell"]
                },
                "DMSASL54": {
                    title: "DMSASL54",
                    desc: "Smart access door lock",
                    img: "./images/doorlock/13.png",
                    features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App", "Doorbell"]
                },
                "DS812": {
                    title: "DS812",
                    desc: "Multi-access door lock",
                    img: "./images/doorlock/14.png",
                    features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App", "Doorbell"]
                },
                "DMSSL56": {
                    title: "DMSSL56",
                    desc: "Smart lock with advanced features",
                    img: "./images/doorlock/15.png",
                    features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App"]
                },
                "DMRSL55": {
                    title: "DMRSL55",
                    desc: "Reliable smart door lock",
                    img: "./images/doorlock/16.png",
                    features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App"]
                },
                "DMSSL57": {
                    title: "DMSSL56",
                    desc: "Smart lock with advanced features",
                    img: "./images/doorlock/17.png",
                    features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App"]
                },
                "DMSSL58": {
                    title: "DMSSL58",
                    desc: "Secure smart lock system",
                    img: "./images/doorlock/18.png",
                    features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App"]
                },
                "DMFSL": {
                    title: "DMFSL",
                    desc: "Fingerprint smart lock",
                    img: "./images/doorlock/19.png",
                    features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App"]
                },
                "DMRSL59": {
                    title: "DMRSL59",
                    desc: "Advanced smart lock",
                    img: "./images/doorlock/20.png",
                    features: ["Fingerprint", "Password", "ID Card", "Key", "Mobile App"]
                }
            }
        },
        "PROCESSOR": {
            title: "Processor",
            desc: "High-performance automation processors.",
            subProducts: {
                "LUMI MINI": {
                    title: "LUMI MINI",
                    desc: "Intel N2830 Dual Core, 4GB RAM + 128GB SSD, dual USB 2.0 & 3.0 ports, compact aluminium body, Gigabit Ethernet & Wi-Fi.",
                    img: "./images/processor/21.png",
                    features: ["Intel N2830 Dual Core", "4GB RAM + 128GB SSD", "Dual USB 2.0 & 3.0 ports", "Compact aluminium body", "Gigabit Ethereum & Wi-Fi"]
                },
                "LUMI PLUS": {
                    title: "LUMI PLUS",
                    desc: "Intel N5105 (2.0–2.9 GHz), 8GB RAM + 128GB SSD, dual USB 2.0 & USB 3.0 ports, compact plastic body, Gigabit Ethernet & Wi-Fi.",
                    img: "./images/processor/22.png",
                    features: ["Intel N5105 (2.0–2.9 GHz)", "8GB RAM + 128GB SSD", "Dual USB 2.0 & USB 3.0 ports", "Compact plastic body", "Gigabit Ethereum & Wi-Fi"]
                },
                "LUMI ULTRA": {
                    title: "LUMI ULTRA",
                    desc: "Intel i7 (2.8–4.7 GHz), 16GB RAM + 256GB SSD, aluminium body, dual USB 2.0 & USB 3.0 ports, Gigabit Ethereum & Wi-Fi.",
                    img: "./images/processor/23.png",
                    features: ["Intel i7 (2.8–4.7 GHz)", "16GB RAM + 256GB SSD", "Aluminium body", "Dual USB 2.0 & USB 3.0 ports", "Gigabit Ethereum & Wi-Fi"]
                }
            }
        },
        "LUMI GLASS SERIES": {
            title: "LUMI Glass Series",
            desc: "Modular glass touch panels in multiple model sizes.",
            subProducts: {
                "2 MODEL": {
                    title: "2 MODEL",
                    desc: "Frame size 85×85×8 mm, fits 2M box, available in black & white glass colours.",
                    img: "./images/lumiglass/24.png",
                    features: ["Frame size 85×85×8 mm", "Fits 2M box", "Black & white glass colours"]
                },
                "4 MODEL": {
                    title: "4 MODEL",
                    desc: "Frame size 150×85×8 mm, 4M variants (2 Quads / 1 Quad + 1 Blank), fits 4M box, available in black & white glass colours.",
                    img: "./images/lumiglass/25.png",
                    features: ["Frame size 150×85×8 mm", "4M variants (2 Quads / 1 Quad + 1 Blank)", "Fits 4M box", "Black & white glass colours"]
                },
                "6 MODEL": {
                    title: "6 MODEL",
                    desc: "Frame size 220×85×8 mm, 6M variants (3 Quads / 2 Quads + 1 Blank / 1 Quad + 2 Blanks), fits 6M box, available in black & white glass colours.",
                    img: "./images/lumiglass/26.png",
                    features: ["Frame size 220×85×8 mm", "6M variants", "Fits 6M box", "Black & white glass colours"]
                },
                "8 MODEL": {
                    title: "8 MODEL",
                    desc: "Frame size 240×90×8 mm, 8M variants (3 Quads / 2 Quads + 1 Blank / 1 Quad + 2 Blanks), fits 8M box, available in black & white glass colours.",
                    img: "./images/lumiglass/26.png",
                    features: ["Frame size 240×90×8 mm", "8M variants", "Fits 8M box", "Black & white glass colours"]
                },
                "12 MODEL": {
                    title: "12 MODEL",
                    desc: "Frame size 220×155×8 mm, 12M variant (3 Quads + 3 Blanks), fits 12M box, available in black & white glass colours.",
                    img: "./images/lumiglass/27.png",
                    features: ["Frame size 220×155×8 mm", "12M variant (3 Quads + 3 Blanks)", "Fits 12M box", "Black & white glass colours"]
                }
            }
        },
        "ESCULT SERIES": {
            title: "Escult Series",
            desc: "Designer sculpted smart touch panels.",
            subProducts: {
                "2 MODEL": {
                    title: "2 MODEL",
                    desc: "Board size 114×86×9 mm, fits 2M box, available in 9 Colors and 27 Finish",
                    img: "./images/escultseries/28.png",
                    features: ["Board size 114×86×9 mm", "Fits 2M box", "9 Colors", "27 Finish"]
                },
                "4 MODEL": {
                    title: "4 MODEL",
                    desc: "Board size 174×86×9 mm, fits 4M box, available in 9 Colors and 27 Finish",
                    img: "./images/escultseries/29.png",
                    features: ["Board size 174×86×9 mm", "Fits 4M box", "9 Colors", "27 Finish"]
                },
                "6 MODEL": {
                    title: "6 MODEL",
                    desc: "Board size 250×86×9 mm, fits 6M box, available in 9 Colors and 27 Finish",
                    img: "./images/escultseries/30.png",
                    features: ["Board size 250×86×9 mm", "Fits 6M box", "9 Colors", "27 Finish"]
                },
                "8 MODEL": {
                    title: "8 MODEL",
                    desc: "Board size 250×86×9 mm, fits 8M box, available in 9 Colors and 27 Finish",
                    img: "./images/escultseries/30.png",
                    features: ["Board size 250×86×9 mm", "Fits 8M box", "9 Colors", "27 Finish"]
                }
            }
        },
        "WALL MOUNT DISPLAY": {
            title: "Wall Mount Display",
            desc: "Android-powered wall mount tablets.",
            subProducts: {
                "10\" POE ANDROID WALL MOUNT TABLET": {
                    title: "10\" POE ANDROID WALL MOUNT TABLET",
                    desc: "RK3566 Quad-core, Android 11, 4GB RAM + 16GB ROM, 10\" IPS display (800×1280, 500 nits), PoE & 12V power, USB-C & RS485, Wi-Fi/Bluetooth/Ethernet, durable metal body.",
                    img: "./images/walldisplay/37.png",
                    features: ["RK3566 Quad-core", "Android 11", "4GB RAM + 16GB ROM", "10\" IPS display (800×1280, 500 nits)", "PoE & 12V power", "USB-C & RS485", "Wi-Fi/Bluetooth/Ethernet", "Durable metal body"]
                },
                "4\" POE ANDROID WALL MOUNT TABLET": {
                    title: "4\" POE ANDROID WALL MOUNT TABLET",
                    desc: "RK3566 Quad-core, Android 11, 2GB RAM + 16GB ROM, 4\" IPS display (480×480), PoE & AC power, USB-C/RS485/Speaker/Mic, Wi-Fi/Bluetooth/Ethernet, durable in-wall design (White/Black).",
                    img: "./images/walldisplay/36.png",
                    features: ["RK3566 Quad-core", "Android 11", "2GB RAM + 16GB ROM", "4\" IPS display (480×480)", "PoE & AC power", "USB-C/RS485/Speaker/Mic", "Wi-Fi/Bluetooth/Ethernet", "Durable in-wall design (White/Black)"]
                }
            }
        },
        "TACTILE HEXA SERIES": {
            title: "Tactile Hexa Series",
            desc: "Premium tactile switches and controls.",
            subProducts: {
                "6 BUTTON KNX SWITCH": {
                    title: "6 BUTTON KNX SWITCH",
                    desc: "KNX BUS protocol, CNC metal build, 21–30 VDC input, max 90% humidity, 86×86×24 mm size, –5° to +45°C operating range, ETS-configurable backlight LED.",
                    img: "./images/hexaseries/38.png",
                    features: ["KNX BUS protocol", "CNC metal build", "21–30 VDC input", "Max 90% humidity", "86×86×24 mm size", "–5° to +45°C operating range", "ETS-configurable backlight LED"]
                },
                "MULTI SOCKET + 2 USB": {
                    title: "MULTI SOCKET + 2 USB",
                    desc: "CNC metal body, 230V AC input, max 90% humidity, 86×86×24 mm size, –5° to +45°C operating temperature.",
                    img: "./images/hexaseries/39.png",
                    features: ["CNC metal body", "230V AC input", "Max 90% humidity", "86×86×24 mm size", "–5° to +45°C operating temperature"]
                },
                "DND SWITCH": {
                    title: "DND SWITCH",
                    desc: "CNC metal, 230V AC, max 90% humidity, 86×86×24 mm, –5° to +45°C, features: Calling Bell, DND, Clean Room, Wait.",
                    img: "./images/hexaseries/40.png",
                    features: ["CNC metal", "230V AC", "Max 90% humidity", "86×86×24 mm", "–5° to +45°C", "Calling Bell", "DND", "Clean Room", "Wait"]
                },
                "RFIC CARD READER": {
                    title: "RFIC CARD READER",
                    desc: "CNC metal, 230V AC, max 90% humidity, 86×86×24 mm, –5° to +45°C, supports 13.56 MHz IC cards.",
                    img: "./images/hexaseries/41.png",
                    features: ["CNC metal", "230V AC", "Max 90% humidity", "86×86×24 mm", "–5° to +45°C", "Supports 13.56 MHz IC cards"]
                },
                "THERMOSTAT": {
                    title: "THERMOSTAT",
                    desc: "KNX protocol, aluminium CNC finish, 21–30 VDC, max 90% humidity, 86×86×24 mm, –5° to 45°C operating range.",
                    img: "./images/hexaseries/42.png",
                    features: ["KNX protocol", "Aluminium CNC finish", "21–30 VDC", "Max 90% humidity", "86×86×24 mm", "–5° to 45°C operating range"]
                }
            }
        },
        "DUO-QUAD SERIES": {
            title: "Duo-Quad Series",
            desc: "Advanced KNX control devices.",
            subProducts: {
                "8 BUTTON KNX SWITCH": {
                    title: "8 BUTTON KNX SWITCH",
                    desc: "KNX BUS device, CNC metal body, 21–30 VDC, max 90% humidity, 86×86×24 mm, –5° to +45°C operating range.",
                    img: "./images/duoquad/43.png",
                    features: ["KNX BUS device", "CNC metal body", "21–30 VDC", "Max 90% humidity", "86×86×24 mm", "–5° to +45°C operating range"]
                },
                "8 BUTTON KNX SWITCH WITH 4 GANG RELAY": {
                    title: "8 BUTTON KNX SWITCH WITH 4 GANG RELAY",
                    desc: "KNX BUS 4×16A output module CNC metal, 21–30 VDC, max 90% humidity, 86×86×24 mm, –5° to +45°C operating range.",
                    img: "./images/duoquad/44.png",
                    features: ["KNX BUS 4×16A output module", "CNC metal", "21–30 VDC", "Max 90% humidity", "86×86×24 mm", "–5° to +45°C operating range"]
                },
                "THERMOSTAT": {
                    title: "THERMOSTAT",
                    desc: "KNX device – aluminium CNC finish, 21–30 VDC, max 90% humidity, 86×86×24 mm, –5° to 45°C operating range.",
                    img: "./images/duoquad/45.png",
                    features: ["KNX device", "Aluminium CNC finish", "21–30 VDC", "Max 90% humidity", "86×86×24 mm", "–5° to 45°C operating range"]
                },
                "SOCKET": {
                    title: "SOCKET",
                    desc: "KNX protocol, aluminium CNC finish, 21–30 VDC, max 90% humidity, 86×86×24 mm, –5° to 45°C operating range.",
                    img: "./images/duoquad/46.png",
                    features: ["KNX protocol", "Aluminium CNC finish", "21–30 VDC", "Max 90% humidity", "86×86×24 mm", "–5° to 45°C operating range"]
                }
            }
        },
        "DOMOGENIE GLASS LITE SERIES": {
            title: "Domogenie Glass Lite Series",
            desc: "Tempered glass switch modules with RGB backlight.",
            subProducts: {
                "2 MODULE": {
                    title: "2 MODULE",
                    desc: "86×86×35.7 mm, 230V AC (N+L), 100W fan/dimmer, 30A relay, WiFi/ZigBee, tempered glass + aluminium frame, RGB backlight, black/white/custom options.",
                    img: "./images/domoglass/31.png",
                    features: ["86×86×35.7 mm", "230V AC (N+L)", "100W fan/dimmer", "30A relay", "WiFi/ZigBee", "Tempered glass + aluminium frame", "RGB backlight", "Black/white/custom options"]
                },
                "4 MODULE": {
                    title: "4 MODULE",
                    desc: "450×86×38.9 mm, tempered glass + aluminium frame, supports cast options.",
                    img: "./images/domoglass/32.png",
                    features: ["450×86×38.9 mm", "230V AC (N+L)", "100W fan/dimmer", "30A relay", "WiFi/ZigBee", "Tempered glass + aluminium frame", "RGB backlight", "Black/white/custom glass w/ black/silver/gold frame"]
                },
                "6 MODULE": {
                    title: "6 MODULE",
                    desc: "234×86×37.2 mm tempered glass panel.",
                    img: "./images/domoglass/33.png",
                    features: ["234×86×37.2 mm", "230V AC (N+L)", "100W fan/dimmer", "30A relay", "WiFi/ZigBee", "Tempered glass + aluminium frame", "RGB backlight", "Black/white/custom glass w/ black/silver/gold frame"]
                },
                "8 MODULE": {
                    title: "8 MODULE",
                    desc: "253×86×38.2 mm panel for premium installs.",
                    img: "./images/domoglass/34.png",
                    features: ["253×86×38.2 mm", "230V AC (N+L)", "100W fan/dimmer", "30A relay", "WiFi/ZigBee", "Tempered glass + aluminium frame", "RGB backlight", "Black/white/custom glass w/ black/silver/gold frame"]
                },
                "12 MODULE": {
                    title: "12 MODULE",
                    desc: "237×152×37.2 mm, multi-module panel.",
                    img: "./images/domoglass/35.png",
                    features: ["237×152×37.2 mm", "230V AC (N+L)", "100W fan/dimmer", "30A relay", "WiFi/ZigBee", "Tempered glass + aluminium frame", "RGB backlight", "Black/white/custom glass w/ black/silver/gold frame"]
                }
            }
        },
        "TREMBLAY SOUNDS": {
            title: "Tremblay Sounds",
            desc: "Premium audio solutions.",
            subProducts: {
                "MULTIROOM AUDIO CEILING SPEAKER": {
                    title: "Multiroom Audio Ceiling Speaker",
                    desc: "In-ceiling streaming speaker with built-in amplifier.",
                    img: "./images/tremblay/53.png",
                    features: ["Built-in amplifier", "Wi-Fi/Bluetooth/Ethernet", "50W×2 output", "6.5\" glass-fibre woofer + 1\" aluminium tweeter", "40–20kHz response", "Supports AirPlay/DLNA/Spotify Connect"]
                }
            }
        },
        "Z-WAVE RELAY": {
            title: "Z-Wave Relay",
            desc: "Multi-channel relay modules and accessories.",
            relay: true,
            img: "./images/relay/47.png"
        },
        "CURTAIN MOTORS": {
            title: "Curtain Motors",
            desc: "Smart curtain motor systems.",
            subProducts: {
                "N+ KNX SERIES CURTAIN MOTOR": {
                    title: "N+ KNX SERIES CURTAIN MOTOR",
                    desc: "Dual KNX + 433MHz control, real-time feedback, works with all KNX devices, KNX 21–30VDC & 100–240V AC motor, 1.5 N·m torque, 50kg load, 13cm/s speed, 0.9–12m width, >4min runtime, <28dB noise, IP20, –10°C to +55°C.",
                    img: "./images/curtain/51.png",
                    features: ["Dual KNX + 433MHz control", "Real-time feedback", "Works with all KNX devices", "KNX 21–30VDC & 100–240V AC motor", "1.5 N·m torque", "50kg load", "13cm/s speed", "0.9–12m width", ">4min runtime", "<28dB noise", "IP20", "–10°C to +55°C"]
                },
                "LUMI N+ 5 WIRE MOTOR": {
                    title: "LUMI N+ 5 WIRE MOTOR",
                    desc: "Dual KNX + RF control, real-time feedback, fully KNX compatible, KNX 21–30VDC & 100–240V AC motor, 1.5 N·m torque, 50kg load, 13cm/s speed, 0.9–12m width, >4min runtime, <28dB noise, IP20, –10°C to +55°C.",
                    img: "./images/curtain/52.png",
                    features: ["Dual KNX + RF control", "Real-time feedback", "Fully KNX compatible", "KNX 21–30VDC & 100–240V AC motor", "1.5 N·m torque", "50kg load", "13cm/s speed", "0.9–12m width", ">4min runtime", "<28dB noise", "IP20", "–10°C to +55°C"]
                }
            }
        },
        "SENSORS": {
            title: "Sensors",
            desc: "Advanced detection and monitoring sensors for smart homes.",
            subProducts: {
                "FALL DETECTION SENSOR": {
                    title: "Fall Detection Sensor",
                    desc: "Advanced AI-powered fall detection sensor with emergency alert system.",
                    img: "./images/sensors/56.png",
                    features: ["AI-powered fall detection", "Emergency alert system", "24/7 monitoring", "Wi-Fi/Bluetooth connectivity", "Long battery life", "Water-resistant design"]
                },
                "HUMAN PRESENCE SENSOR": {
                    title: "Human Presence Sensor",
                    desc: "Microwave-based presence detection with high accuracy and wide coverage.",
                    img: "./images/sensors/55.png",
                    features: ["Microwave detection technology", "360° coverage", "Adjustable sensitivity", "Built-in temperature sensor", "Energy saving mode", "Easy installation"]
                },
                "OCCUPANCY SENSOR": {
                    title: "Occupancy Sensor",
                    desc: "Motion-based occupancy detection for lighting and HVAC control.",
                    img: "./images/sensors/54.png",
                    features: ["PIR motion detection", "Time-delay adjustment", "Lux level sensing", "Dual-technology option", "Ceiling/wall mount", "Energy compliance certified"]
                }
            }
        }
    };
/* ------------------------- PRODUCT DATA ADDITIONS ------------------------- */
// Add these to the productData object, after the SENSORS category:
productData["AUTOMATION DISTRIBUTION BOX"] = {
    title: "Automation Distribution Box",
    desc: "Professional distribution boxes for automation system components.",
    brand: "DB",
    subProducts: {
        "SMART DB 12 WAY": {
            title: "Smart DB 12 Way",
            desc: "12-way automation distribution box with modular design",
            img: "./images/db/57.png", // You'll need to add this image
            features: ["12 modular spaces", "DIN rail mounting", "Transparent cover", "IP65 rated", "Wall mountable", "Cable management"]
        },
        "SMART DB 24 WAY": {
            title: "Smart DB 24 Way",
            desc: "24-way automation distribution box for larger installations",
            img: "./images/db/58.png", // You'll need to add this image
            features: ["24 modular spaces", "DIN rail mounting", "Lockable transparent cover", "IP65 rated", "Wall mountable", "Advanced cable management"]
        }
    }
};

productData["NETWORK DISTRIBUTION BOX"] = {
    title: "Network Distribution Box",
    desc: "Distribution boxes for network and communication equipment.",
    brand: "DB",
    subProducts: {
        "NETWORK DB 8 PORT": {
            title: "Network DB 8 Port",
            desc: "8-port network distribution box with patch panel",
            img: "./images/db/59.png", // You'll need to add this image
            features: ["8-port patch panel", "Cable management", "Ventilation slots", "Wall mountable", "Lockable door", "Rack mount options"]
        },
        "NETWORK DB 16 PORT": {
            title: "Network DB 16 Port",
            desc: "16-port network distribution box for enterprise installations",
            img: "./images/db/60.png", // You'll need to add this image
            features: ["16-port patch panel", "Advanced cable management", "Cooling fan", "Wall/rack mountable", "Lockable door", "Power strip included"]
        }
    }
};

const PRODUCT_ORDER = [
    "DOOR LOCK",
    "PROCESSOR",
    "LUMI GLASS SERIES",
    "ESCULT SERIES",
    "TACTILE HEXA SERIES",
    "DUO-QUAD SERIES",
    "DOMOGENIE GLASS LITE SERIES",
    "WALL MOUNT DISPLAY",
    "TREMBLAY SOUNDS",
    "Z-WAVE RELAY",
    "CURTAIN MOTORS",
    "SENSORS",
    "AUTOMATION DISTRIBUTION BOX",  // Add this line
    "NETWORK DISTRIBUTION BOX"      // Add this line
];

    /* ------------------------- UI BUILD ------------------------- */
    const productListEl = document.getElementById('productList');
    const pTitle = document.getElementById('pTitle');
    const pDesc = document.getElementById('pDesc');
    const pMeta = document.getElementById('pMeta');
    const pFeatures = document.getElementById('pFeatures');
    const featuresSection = document.getElementById('featuresSection');
    const productImage = document.getElementById('productImage');
    const productImageOverlay = document.getElementById('productImageOverlay');
    const previewImage = document.getElementById('previewImage');
    const imgInner = document.getElementById('imgInner');
    const imgContainer = document.getElementById('imgContainer');
    const relayControlsEl = document.getElementById('relayControls');
    const relayOptionsList = document.getElementById('relayOptionsList');
    const productModalEl = document.getElementById('productModal');
    const modalProductTitle = document.getElementById('modalProductTitle');
    const modalProductDesc = document.getElementById('modalProductDesc');
    const modalProductImage = document.getElementById('modalProductImage');
    const modalProductFeatures = document.getElementById('modalProductFeatures');
    const modalCloseBtn = document.getElementById('modalCloseBtn');

    const relayOptions = [
        { id: 'relay-1ch', label: '1 Channel Relay' },
        { id: 'relay-2ch', label: '2 Channel Relay' },
        { id: 'relay-curtain', label: '1 Channel Curtain Relay' },
        { id: 'relay-dimmer', label: '0-10V Analog Dimmer' },
        { id: 'relay-remote', label: 'LS Series Remote' }
    ];

    const relayOptionImages = {
        'relay-1ch': './images/relay/48.png',
        'relay-2ch': './images/relay/49.png',
        'relay-curtain': './images/relay/47.png',
        'relay-dimmer': './images/relay/50.png',
        'relay-remote': './images/relay/48.png'
    };

    const relayState = relayOptions.reduce((acc, opt) => {
        acc[opt.id] = { selected: false, quantity: 1 };
        return acc;
    }, {});
    let lastRelaySelectionLabel = '';

    function relaySelectionsFromState() {
        return relayOptions
            .filter(opt => relayState[opt.id].selected)
            .map(opt => ({ name: opt.label, quantity: relayState[opt.id].quantity, id: opt.id }));
    }

    function updateRelayOverlay() {
        if (currentProduct !== 'Z-WAVE RELAY') {
            productImageOverlay.style.display = 'none';
            productImageOverlay.textContent = '';
            return;
        }
        const selections = relaySelectionsFromState();
        productImageOverlay.style.display = 'block';
        if (selections.length === 0) {
            productImageOverlay.textContent = 'Select relay modules to highlight them.';
            resetRelayPreview();
            return;
        }
        const preferred = selections.find(sel => sel.name === lastRelaySelectionLabel) || selections[selections.length - 1];
        productImageOverlay.innerHTML = `<strong>${preferred.name}</strong><br>Qty ${preferred.quantity}`;
        setRelayPreview(preferred.id);
    }

    function setRelayPreview(optionId) {
        const baseImg = productData['Z-WAVE RELAY']?.img || '';
        const src = relayOptionImages[optionId] || baseImg;
        if (currentProduct === 'Z-WAVE RELAY' && src) {
            productImage.src = src;
        }
    }

    function resetRelayPreview() {
        const baseImg = productData['Z-WAVE RELAY']?.img || '';
        if (currentProduct === 'Z-WAVE RELAY' && baseImg) {
            productImage.src = baseImg;
        }
    }

    const switchFamilies = new Set([
        "LUMI GLASS SERIES",
        "ESCULT SERIES",
        "TACTILE HEXA SERIES",
        "DUO-QUAD SERIES",
        "DOMOGENIE GLASS LITE SERIES"
    ]);

    const seriesCounters = {};

function getSeriesCode(productKey) {
    if (productKey === 'DOOR LOCK') return 'L';
    if (productKey === 'PROCESSOR') return 'P';
    if (productKey === 'WALL MOUNT DISPLAY') return 'D';
    if (productKey === 'CURTAIN MOTORS') return 'C';
    if (productKey === 'Z-WAVE RELAY') return 'R';
    if (productKey === 'TREMBLAY SOUNDS') return 'T';
    if (productKey === 'AUTOMATION DISTRIBUTION BOX') return 'ADB'; // Added
    if (productKey === 'NETWORK DISTRIBUTION BOX') return 'NDB';   // Added
    if (switchFamilies.has(productKey)) return 'S';
    return 'S';
}

    /* ------------------------- LOAD FLOOR PLAN IMAGE ------------------------- */
    function loadFloorPlanImage() {
        const previewImage = document.getElementById('previewImage');
        
        // Check for NEW uploaded image first (has priority)
        const uploadedFloorPlan = sessionStorage.getItem('uploadedFloorPlan');
        const exportedPlan = sessionStorage.getItem('exportedPlan');
        
        // Clear any existing image source to force reload
        previewImage.src = '';
        
        if (uploadedFloorPlan) {
            // User uploaded a new image from index.html
            console.log('📤 Loading uploaded floor plan from index.html');
            previewImage.src = uploadedFloorPlan;
            
            // Clear ONLY the uploadedFloorPlan, keep exportedPlan for backup
            sessionStorage.removeItem('uploadedFloorPlan');
            
        } else if (exportedPlan) {
            // User exported from floor planner
            console.log('🏠 Loading exported floor plan from floor planner');
            previewImage.src = exportedPlan;
            
            // Keep exportedPlan in storage for refreshes
            
        } else {
            // No stored images, use default
            console.log('🏢 Using default floor plan image');
            previewImage.src = 'https://virtualtourslasvegas.com/wp-content/uploads/2023/01/1701-N-Green-Valley-Pkwy-8A.jpg';
        }
        
        // Update image dimensions when loaded
        previewImage.onload = function() {
            console.log('✅ Floor plan image loaded successfully');
            updateImageDimensions();
            
            // Clear any previous marks and wires when new image loads
            clearAllMarksAndWires();
        };
        
        // Handle image load errors
        previewImage.onerror = function() {
            console.error('❌ Failed to load floor plan image');
            
            // Try fallback in this order:
            // 1. Check if there's an exported plan
            const exportedFallback = sessionStorage.getItem('exportedPlan');
            if (exportedFallback && previewImage.src !== exportedFallback) {
                console.log('🔄 Trying exported plan as fallback');
                previewImage.src = exportedFallback;
                return;
            }
            
            // 2. Use default image
            console.log('🔄 Using default image as fallback');
            previewImage.src = 'https://virtualtourslasvegas.com/wp-content/uploads/2023/01/1701-N-Green-Valley-Pkwy-8A.jpg';
        };
    }

    // Clear all marks and wires when new image loads
    function clearAllMarksAndWires() {
        // Remove all marks
        marks.forEach(mark => {
            if (mark.el && mark.el.parentNode) {
                mark.el.parentNode.removeChild(mark.el);
            }
        });
        marks.length = 0;
        
        // Remove all wires
        wires.forEach(wire => {
            if (wire.element && wire.element.svg) {
                wire.element.svg.remove();
            }
        });
        wires.length = 0;
        
        // Reset counters
        markCounter = 0;
        selectedMarkId = null;
        
        // Reset wire mode
        isWireMode = false;
        currentWireType = null;
        wireStartMark = null;
        wireEndMark = null;
        selectedWire = null;
        wirePoints = [];
        
        // Update UI
        renderMarksList();
        updateWiresList();
        hideWireControls();
        
        console.log('🧹 Cleared all marks and wires for new image');
    }

    function nextSeriesLabel(productKey) {
        const code = getSeriesCode(productKey);
        
        const existingMarks = marks.filter(mark => mark.seriesCode === code);
        
        if (existingMarks.length > 0) {
            const existingNumbers = existingMarks.map(mark => {
                const num = parseInt(mark.seriesLabel.substring(1));
                return isNaN(num) ? 0 : num;
            });
            
            let nextNum = 1;
            while (existingNumbers.includes(nextNum)) {
                nextNum++;
            }
            
            seriesCounters[code] = nextNum;
            return { seriesCode: code, label: `${code}${nextNum}` };
        } else {
            seriesCounters[code] = 1;
            return { seriesCode: code, label: `${code}1` };
        }
    }

    let currentProduct = null;
    let currentSubProduct = null;
    let imageScale = 1;
    const marks = []; // {id, x, y, size, shape, el, productData, tooltip}
    let selectedMarkId = null;
    let imageNaturalWidth = 0;
    let imageNaturalHeight = 0;
    let imageDisplayWidth = 0;
    let imageDisplayHeight = 0;

    // Wire Mapping variables
    const wires = []; // Array to store all wire connections
    let isWireMode = false; // Whether we're in wire connection mode
    let currentWireType = null; // 'knx', 'phase', 'neutral'
    let currentWireMode = 'curve'; // 'curve' or 'points'
    let wireStartMark = null; // First selected mark for wiring
    let wireEndMark = null; // Second selected mark for wiring
    let selectedWire = null; // Currently selected wire
    let wirePoints = []; // Array of points for point-based wires

    // Wire Types configuration
    const wireTypes = [
        {
            id: 'knx',
            name: 'KNX_WIRE',
            title: 'KNX Bus Wire',
            color: '#4CAF50',
            icon: 'electric_bolt',
            bgColor: '#f0f9f0',
            borderColor: '#c8e6c9'
        },
        {
            id: 'phase',
            name: 'PHASE_WIRE',
            title: 'Phase Wire (Live)',
            color: '#f44336',
            icon: 'flash_on',
            bgColor: '#ffebee',
            borderColor: '#ffcdd2'
        },
        {
            id: 'neutral',
            name: 'NEUTRAL_WIRE',
            title: 'Neutral Wire',
            color: '#000000',
            icon: 'power',
            bgColor: '#f5f5f5',
            borderColor: '#e0e0e0'
        }
    ];

    function orientTooltip(mark) {
        const tooltip = mark?.tooltip;
        if (!tooltip || !imageNaturalWidth || !imageNaturalHeight) return;
        const offset = 12;
        const centerX = mark.x + (mark.size / 2);
        const centerY = mark.y + (mark.size / 2);
        const verticalIsBottom = centerY < (imageNaturalHeight / 2);
        const horizontalIsRight = centerX < (imageNaturalWidth / 2);

        tooltip.dataset.vertical = verticalIsBottom ? 'bottom' : 'top';
        tooltip.dataset.horizontal = horizontalIsRight ? 'right' : 'left';

        if (verticalIsBottom) {
            tooltip.style.top = '100%';
        } else {
            tooltip.style.top = '0';
        }

        if (horizontalIsRight) {
            tooltip.style.left = '100%';
        } else {
            tooltip.style.left = '0';
        }

        const translateX = horizontalIsRight ? `${offset}px` : `calc(-100% - ${offset}px)`;
        const translateY = verticalIsBottom ? `${offset}px` : `calc(-100% - ${offset}px)`;
        tooltip.style.transform = `translate(${translateX}, ${translateY})`;
    }

    function populateModal(mark) {
        if (!mark) return;
        const title = `${mark.categoryName || ''}${mark.modelName ? ' — ' + mark.modelName : ''}`.trim() || 'Product';
        modalProductTitle.textContent = title;
        modalProductDesc.textContent = mark.desc || '';
        const imageSrc = mark.imageSrc || previewImage.src;
        if (imageSrc) {
            modalProductImage.src = imageSrc;
            modalProductImage.style.display = 'block';
        } else {
            modalProductImage.style.display = 'none';
        }
        modalProductFeatures.innerHTML = '';
        const featureList = (mark.features && mark.features.length ? mark.features : ['No features provided']).slice(0, 12);
        featureList.forEach(feature => {
            const li = document.createElement('li');
            li.textContent = feature;
            modalProductFeatures.appendChild(li);
        });
    }

    function openProductModal(mark) {
        populateModal(mark);
        productModalEl.classList.add('show');
    }

    function closeProductModal() {
        productModalEl.classList.remove('show');
    }

    modalCloseBtn.addEventListener('click', closeProductModal);
    productModalEl.addEventListener('click', (e) => {
        if (e.target === productModalEl) {
            closeProductModal();
        }
    });

    function buildList() {
        productListEl.innerHTML = '';
        
        // Add Wire Mapping options at the top
        wireTypes.forEach(wireType => {
            const wireItem = document.createElement('div');
            wireItem.className = 'tab-btn';
            wireItem.dataset.name = wireType.name;
            wireItem.dataset.wireType = wireType.id;
            wireItem.innerHTML = `
                <div class="tab-title" style="color: ${wireType.color}; font-weight: 600;">
                    <span class="material-icons" style="font-size: 18px; margin-right: 8px; vertical-align: middle;">${wireType.icon}</span>
                    ${wireType.title}
                </div>
                <div class="tab-sub">
                    <span class="material-icons" style="font-size:20px;color:${wireType.color}">add_link</span>
                </div>
            `;
            wireItem.addEventListener('click', () => {
                // Set current wire type
                currentWireType = wireType.id;
                isWireMode = true;
                
                // Set active class on all wire items
                document.querySelectorAll('.tab-btn[data-name^="KNX_WIRE"], .tab-btn[data-name^="PHASE_WIRE"], .tab-btn[data-name^="NEUTRAL_WIRE"]').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.name === wireType.name);
                });
                
                // Show wire controls in middle panel
                showWireControls();
                showNotification(`${wireType.title} Mode: Select two marks to connect them`, 'info');
            });
            productListEl.appendChild(wireItem);
        });
        
        // Add separator
        const separator = document.createElement('div');
        separator.style.height = '1px';
        separator.style.backgroundColor = 'var(--border)';
        separator.style.margin = '15px 0';
        productListEl.appendChild(separator);
        
        const keys = PRODUCT_ORDER.length ? PRODUCT_ORDER.filter(k => productData[k]) : Object.keys(productData);
        for (const key of keys) {
            const item = document.createElement('div');
            item.className = 'tab-btn';
            item.dataset.name = key;

            const left = document.createElement('div');
            left.className = 'tab-title';
            left.textContent = key;

            const right = document.createElement('div');
            right.className = 'tab-sub';

            if (productData[key].subProducts) {
                right.innerHTML = '<span class="material-icons" style="font-size:20px;color:var(--muted)">expand_more</span>';
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const existing = item.nextElementSibling;
                    if (existing && existing.classList.contains('sub-product-list')) {
                        existing.remove();
                        item.querySelector('.material-icons').textContent = 'expand_more';
                    } else {
                        createSubProducts(item, key);
                        item.querySelector('.material-icons').textContent = 'expand_less';
                    }
                });
            } else {
                item.addEventListener('click', () => selectProduct(key));
            }

            item.appendChild(left);
            item.appendChild(right);
            productListEl.appendChild(item);
        }
    }

    function createSubProducts(afterItem, productKey) {
        const wrap = document.createElement('div');
        wrap.className = 'sub-product-list';
        wrap.style.marginTop = '8px';
        wrap.style.marginBottom = '8px';
        wrap.style.paddingLeft = '8px';
        wrap.style.borderLeft = '2px solid var(--border)';

        const subProducts = productData[productKey].subProducts;
        for (const subKey of Object.keys(subProducts)) {
            const btn = document.createElement('div');
            btn.className = 'tab-btn';
            btn.style.background = '#f8f9fa';
            btn.style.border = '1px solid var(--border)';
            btn.dataset.name = productKey + '|' + subKey;
            btn.innerHTML = `<div class="tab-title">${subKey}</div>`;
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                selectProduct(productKey, subKey);
            });
            wrap.appendChild(btn);
        }
        afterItem.parentNode.insertBefore(wrap, afterItem.nextSibling);
    }

    function buildRelayOptions() {
        relayOptionsList.innerHTML = '';
        relayOptions.forEach(option => {
            const row = document.createElement('div');
            row.className = 'relay-option';
            row.dataset.optionId = option.id;
            const label = document.createElement('label');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = relayState[option.id].selected;
            checkbox.addEventListener('change', () => {
                relayState[option.id].selected = checkbox.checked;
                if (checkbox.checked) {
                    lastRelaySelectionLabel = option.label;
                } else {
                    if (lastRelaySelectionLabel === option.label) {
                        lastRelaySelectionLabel = '';
                    }
                }
                updateRelayOverlay();
            });
            label.appendChild(checkbox);
            const span = document.createElement('span');
            span.textContent = option.label;
            label.appendChild(span);
            const qty = document.createElement('input');
            qty.type = 'number';
            qty.min = 1;
            qty.value = relayState[option.id].quantity;
            qty.addEventListener('input', () => {
                const val = Math.max(1, parseInt(qty.value || '1', 10));
                qty.value = val;
                relayState[option.id].quantity = val;
                if (checkbox.checked) {
                    updateRelayOverlay();
                }
            });
            row.appendChild(label);
            const qtyWrap = document.createElement('div');
            qtyWrap.className = 'relay-qty-row';
            const qtyLabel = document.createElement('span');
            qtyLabel.textContent = 'Quantity';
            qtyWrap.appendChild(qtyLabel);
            qtyWrap.appendChild(qty);
            row.appendChild(qtyWrap);
            relayOptionsList.appendChild(row);
        });
        updateRelayOverlay();
    }

    function getSelectedRelayItems() {
        return relaySelectionsFromState();
    }

    function selectProduct(productKey, subProductKey = null) {
        currentProduct = productKey;
        currentSubProduct = subProductKey;

        // Set active class
        document.querySelectorAll('.tab-btn').forEach(b => {
            const isActive = (b.dataset.name === productKey) ||
                (subProductKey && b.dataset.name === (productKey + '|' + subProductKey));
            b.classList.toggle('active', isActive);
        });

        // Get product data
        let data = productData[productKey];
        let title = data.title || productKey;
        let desc = data.desc || '';
        let img = '';
        let features = [];
        const isRelay = productKey === 'Z-WAVE RELAY';

        if (subProductKey && data.subProducts && data.subProducts[subProductKey]) {
            const subData = data.subProducts[subProductKey];
            title = subData.title;
            desc = subData.desc;
            img = subData.img;
            features = subData.features || [];
        } else if (data.subProducts) {
            // Parent category selected
            title = data.title;
            desc = data.desc;
            img = '';
            features = [];
        }

        pTitle.textContent = title;
        pDesc.textContent = desc;

        // Update product image in middle panel
        const resolvedImg = img || data.img || '';
        if (resolvedImg) {
            productImage.src = resolvedImg;
            productImage.style.display = 'block';
        } else {
            productImage.style.display = 'none';
        }

        // Update meta
        pMeta.innerHTML = '';
        if (subProductKey) {
            const meta = document.createElement('div');
            meta.className = 'meta-item';
            meta.textContent = subProductKey;
            pMeta.appendChild(meta);
        }

        // Toggle sections
        if (isRelay) {
            featuresSection.style.display = 'none';
            relayControlsEl.style.display = 'block';
            buildRelayOptions();
            productImageOverlay.style.display = 'block';
            updateRelayOverlay();
        } else {
            relayControlsEl.style.display = 'none';
            featuresSection.style.display = 'block';
            productImageOverlay.style.display = 'none';
            productImageOverlay.textContent = '';
            resetRelayPreview();
            lastRelaySelectionLabel = '';
            // Update features
            pFeatures.innerHTML = '';
            if (features.length > 0) {
                features.forEach(feature => {
                    const li = document.createElement('li');
                    li.textContent = feature;
                    pFeatures.appendChild(li);
                });
            } else {
                const li = document.createElement('li');
                li.textContent = 'Select a sub-product to see features';
                pFeatures.appendChild(li);
            }
        }

        // DO NOT clear marks - allow multiple labels to persist
    }

    /* ------------------------- WIRE MAPPING FUNCTIONS ------------------------- */
    function getWireTypeInfo(type) {
        return wireTypes.find(wt => wt.id === type) || wireTypes[0];
    }

/* ------------------------- UPDATE WIRE CONTROLS UI ------------------------- */
function showWireControls() {
    const wireTypeInfo = getWireTypeInfo(currentWireType);
    
    hideWireControls();
    
    const wireControlsHTML = `
        <div class="mark-controls-box" id="wireControls" style="margin-top: 20px; border-color: ${wireTypeInfo.color};">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="color: ${wireTypeInfo.color}; margin: 0;">
                    <span class="material-icons" style="font-size: 18px; vertical-align: middle; margin-right: 8px;">${wireTypeInfo.icon}</span>
                    ${wireTypeInfo.title} Mapping
                </h3>
                <button id="clearWireSelectionBtn" class="btn" style="padding: 4px 8px; font-size: 11px; background: #f8f9fa; border-color: #ccc;">
                    <span class="material-icons" style="font-size: 14px; margin-right: 4px;">clear</span>
                    Clear
                </button>
            </div>
            
            <div class="form-group">
                <div style="background: ${wireTypeInfo.bgColor}; padding: 12px; border-radius: 8px; margin-bottom: 16px; border: 1px solid ${wireTypeInfo.borderColor};">
                    <div style="font-size: 12px; color: ${wireTypeInfo.color}; margin-bottom: 8px;">
                        <span class="material-icons" style="font-size: 14px; vertical-align: middle; margin-right: 4px;">info</span>
                        Select two marks to connect them with a ${wireTypeInfo.title.toLowerCase()}
                    </div>
                    <div style="font-size: 11px; color: #555; display: flex; align-items: center; gap: 12px;">
                        <span id="wireStartLabel">Start: <strong>None</strong></span>
                        <span class="material-icons" style="font-size: 16px; color: ${wireTypeInfo.color};">arrow_forward</span>
                        <span id="wireEndLabel">End: <strong>None</strong></span>
                    </div>
                </div>
            </div>

            <!-- ... rest of the wire controls HTML remains the same ... -->
            <div class="form-group">
                <label style="color: ${wireTypeInfo.color};">Wire Mode</label>
                <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                    <button id="curveModeBtn" class="btn" style="flex: 1; border-color: ${currentWireMode === 'curve' ? wireTypeInfo.color : '#ccc'}; color: ${currentWireMode === 'curve' ? wireTypeInfo.color : '#666'};">
                        <span class="material-icons" style="font-size: 16px; margin-right: 4px;">timeline</span>
                        Curve Mode
                    </button>
                    <button id="pointsModeBtn" class="btn" style="flex: 1; border-color: ${currentWireMode === 'points' ? wireTypeInfo.color : '#ccc'}; color: ${currentWireMode === 'points' ? wireTypeInfo.color : '#666'};">
                        <span class="material-icons" style="font-size: 16px; margin-right: 4px;">control_point</span>
                        Points Mode
                    </button>
                </div>
            </div>

            <!-- Curve Mode Controls -->
            <div id="curveControls" class="form-group" style="${currentWireMode === 'curve' ? '' : 'display: none;'}">
                <label style="color: ${wireTypeInfo.color};">Wire Curve Level</label>
                <div style="display: flex; align-items: center; gap: 12px;">
                    <span style="font-size: 11px; color: #666;">-100</span>
                    <input type="range" id="wireCurveSlider" min="-100" max="100" value="0" style="flex: 1;">
                    <span style="font-size: 11px; color: #666;">100</span>
                    <span id="curveValue" style="font-size: 12px; font-weight: bold; color: ${wireTypeInfo.color}; min-width: 30px; text-align: center;">0</span>
                </div>
            </div>

            <!-- Points Mode Controls -->
            <div id="pointsControls" class="form-group" style="${currentWireMode === 'points' ? '' : 'display: none;'}">
                <div style="margin-bottom: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="font-size: 12px; color: ${wireTypeInfo.color};">Control Points (${wirePoints.length})</span>
                        <button id="addPointBtn" class="btn" style="padding: 4px 8px; font-size: 11px;">
                            <span class="material-icons" style="font-size: 14px; margin-right: 2px;">add</span>
                            Add Point
                        </button>
                    </div>
                    <div id="pointsList" style="max-height: 80px; overflow-y: auto; padding: 8px; background: #f8f9fa; border-radius: 6px; border: 1px solid var(--border); font-size: 11px;">
                        <div style="color: var(--muted); text-align: center; padding: 4px;">No points added yet</div>
                    </div>
                </div>
                <div style="color: #666; font-size: 10px; padding: 6px; background: #f8f9fa; border-radius: 4px;">
                    <span class="material-icons" style="font-size: 10px; vertical-align: middle; margin-right: 2px;">info</span>
                    Click "Add Point" to add control points • Points are visible only during creation
                </div>
            </div>

            <div class="form-group" id="wireActionButtons" style="display: ${wireStartMark && wireEndMark ? 'block' : 'none'};">
                <button id="createWireBtn" class="btn primary full-width" style="background: ${wireTypeInfo.color}; border-color: ${wireTypeInfo.color};">
                    <span class="material-icons" style="font-size: 16px; margin-right: 8px;">add_link</span>
                    Create ${wireTypeInfo.title}
                </button>
                <button id="cancelWireBtn" class="btn full-width" style="margin-top: 8px; border-color: #666; color: #666;">
                    Cancel
                </button>
            </div>

            <div class="form-group">
                <label style="color: ${wireTypeInfo.color};">Existing ${wireTypeInfo.title}s</label>
                <div id="wiresList" style="max-height: 120px; overflow-y: auto; padding: 8px; background: #f8f9fa; border-radius: 8px; border: 1px solid var(--border);">
                    <div style="color: var(--muted); font-size: 12px; text-align: center; padding: 8px;">No ${wireTypeInfo.title.toLowerCase()}s created yet</div>
                </div>
            </div>

            <div style="margin-top: 12px; color: #666; font-size: 11px; text-align: center; padding: 8px; background: #f8f9fa; border-radius: 6px;">
                <span class="material-icons" style="font-size: 12px; vertical-align: middle; margin-right: 4px;">tips_and_updates</span>
                Wire color: ${wireTypeInfo.title} • Click wire to select • Drag to move • Click Clear to reset
            </div>
        </div>
    `;
    
    const markControlsBox = document.querySelector('.mark-controls-box');
    if (markControlsBox) {
        markControlsBox.insertAdjacentHTML('afterend', wireControlsHTML);
        
        // Re-attach event listeners
        attachWireControlsEvents();
    }
}


/* ------------------------- UPDATE attachWireControlsEvents FUNCTION ------------------------- */
function attachWireControlsEvents() {
    const curveBtn = document.getElementById('curveModeBtn');
    const pointsBtn = document.getElementById('pointsModeBtn');
    const addPointBtn = document.getElementById('addPointBtn');
    const createWireBtn = document.getElementById('createWireBtn');
    const cancelWireBtn = document.getElementById('cancelWireBtn');
    const clearWireSelectionBtn = document.getElementById('clearWireSelectionBtn');
    
    if (curveBtn) {
        curveBtn.addEventListener('click', () => setWireMode('curve'));
    }
    
    if (pointsBtn) {
        pointsBtn.addEventListener('click', () => setWireMode('points'));
    }
    
    if (addPointBtn) {
        addPointBtn.addEventListener('click', addControlPoint);
    }
    
    if (createWireBtn) {
        createWireBtn.addEventListener('click', createWire);
    }
    
    if (cancelWireBtn) {
        cancelWireBtn.addEventListener('click', cancelWire);
    }
    
    if (clearWireSelectionBtn) {
        clearWireSelectionBtn.addEventListener('click', clearWireSelection);
    }
    
    const wireCurveSlider = document.getElementById('wireCurveSlider');
    if (wireCurveSlider) {
        wireCurveSlider.addEventListener('input', function() {
            const curveValue = document.getElementById('curveValue');
            if (curveValue) {
                curveValue.textContent = this.value;
                updateWirePreview();
            }
        });
    }
}  
function hideWireControls() {
        const wireControls = document.getElementById('wireControls');
        if (wireControls) {
            wireControls.remove();
        }
    }

    function setWireMode(mode) {
        currentWireMode = mode;
        wirePoints = [];
        
        // Remove all point elements
        document.querySelectorAll('.draggable-point').forEach(el => el.remove());
        
        // Update button states
        const curveBtn = document.getElementById('curveModeBtn');
        const pointsBtn = document.getElementById('pointsModeBtn');
        const wireTypeInfo = getWireTypeInfo(currentWireType);
        
        if (curveBtn) {
            curveBtn.style.borderColor = mode === 'curve' ? wireTypeInfo.color : '#ccc';
            curveBtn.style.color = mode === 'curve' ? wireTypeInfo.color : '#666';
        }
        if (pointsBtn) {
            pointsBtn.style.borderColor = mode === 'points' ? wireTypeInfo.color : '#ccc';
            pointsBtn.style.color = mode === 'points' ? wireTypeInfo.color : '#666';
        }
        
        // Show/hide controls
        const curveControls = document.getElementById('curveControls');
        const pointsControls = document.getElementById('pointsControls');
        
        if (curveControls) curveControls.style.display = mode === 'curve' ? 'block' : 'none';
        if (pointsControls) pointsControls.style.display = mode === 'points' ? 'block' : 'none';
        
        // Clear preview
        const tempWire = document.querySelector('.wire-preview');
        if (tempWire) {
            tempWire.remove();
        }
        
        // Update preview if we have both marks
        if (wireStartMark && wireEndMark) {
            updateWirePreview();
        }
        
        updatePointsList();
    }

    function updateWireSelectionLabels() {
        const startLabel = document.getElementById('wireStartLabel');
        const endLabel = document.getElementById('wireEndLabel');
        
        if (startLabel && endLabel) {
            startLabel.innerHTML = `Start: <strong>${wireStartMark ? wireStartMark.seriesLabel : 'None'}</strong>`;
            endLabel.innerHTML = `End: <strong>${wireEndMark ? wireEndMark.seriesLabel : 'None'}</strong>`;
            
            const wireActionButtons = document.getElementById('wireActionButtons');
            
            if (wireStartMark && wireEndMark) {
                if (wireActionButtons) wireActionButtons.style.display = 'block';
                updateWirePreview();
            } else {
                if (wireActionButtons) wireActionButtons.style.display = 'none';
            }
        }
    }

    function resetWireSelection() {
        wireStartMark = null;
        wireEndMark = null;
        
        // Remove all point elements
        document.querySelectorAll('.draggable-point').forEach(el => el.remove());
        wirePoints = [];
        
        updateWireSelectionLabels();
        
        // Remove any temporary preview
        const tempWire = document.querySelector('.wire-preview');
        if (tempWire) {
            tempWire.remove();
        }
        
        updatePointsList();
    }

    function addControlPoint() {
        if (!wireStartMark || !wireEndMark) {
            showNotification('Please select start and end marks first', 'error');
            return;
        }
        
        const transform = getImageTransform();
        if (!transform) return;
        
        let newX, newY;
        
        if (wirePoints.length === 0) {
            // First point at midpoint between marks
            const startX = wireStartMark.x + (wireStartMark.size / 2);
            const startY = wireStartMark.y + (wireStartMark.size / 2);
            const endX = wireEndMark.x + (wireEndMark.size / 2);
            const endY = wireEndMark.y + (wireEndMark.size / 2);
            
            newX = (startX + endX) / 2;
            newY = (startY + endY) / 2;
        } else {
            // Add point at midpoint between last point and end mark
            const lastPoint = wirePoints[wirePoints.length - 1];
            const endX = wireEndMark.x + (wireEndMark.size / 2);
            const endY = wireEndMark.y + (wireEndMark.size / 2);
            
            newX = (lastPoint.x + endX) / 2;
            newY = (lastPoint.y + endY) / 2;
        }
        
        const point = {
            id: `point-${Date.now()}`,
            x: newX,
            y: newY,
            element: null
        };
        
        wirePoints.push(point);
        updatePointsList();
        updateWirePreview();
        
        showNotification(`Point added at position X: ${Math.round(newX)}, Y: ${Math.round(newY)}`, 'info');
    }

    function updatePointsList() {
        const pointsList = document.getElementById('pointsList');
        if (!pointsList) return;
        
        pointsList.innerHTML = '';
        
        if (wirePoints.length === 0) {
            pointsList.innerHTML = '<div style="color: var(--muted); text-align: center; padding: 4px;">No points added yet</div>';
            return;
        }
        
        wirePoints.forEach((point, index) => {
            const pointItem = document.createElement('div');
            pointItem.className = 'mark-item';
            pointItem.style.marginBottom = '4px';
            pointItem.style.padding = '6px 8px';
            pointItem.style.fontSize = '11px';
            
            pointItem.innerHTML = `
                <span style="flex: 1;">
                    Point ${index + 1}: X ${Math.round(point.x)}, Y ${Math.round(point.y)}
                </span>
                <button class="btn delete-point-btn" data-point-id="${point.id}" style="padding: 2px 4px; min-height: 20px; font-size: 10px;">
                    <span class="material-icons" style="font-size: 12px;">delete</span>
                </button>
            `;
            
            const deleteBtn = pointItem.querySelector('.delete-point-btn');
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                removeControlPoint(point.id);
            });
            
            pointsList.appendChild(pointItem);
        });
    }

    function removeControlPoint(pointId) {
        const index = wirePoints.findIndex(p => p.id === pointId);
        if (index > -1) {
            if (wirePoints[index].element && wirePoints[index].element.parentNode) {
                wirePoints[index].element.parentNode.removeChild(wirePoints[index].element);
            }
            wirePoints.splice(index, 1);
            updatePointsList();
            updateWirePreview();
        }
    }

    function updateWirePreview() {
        if (!wireStartMark || !wireEndMark || !currentWireType) return;
        
        // Remove existing preview
        const existingPreview = document.querySelector('.wire-preview');
        if (existingPreview) {
            existingPreview.remove();
        }
        
        // Remove existing point elements
        document.querySelectorAll('.draggable-point').forEach(el => el.remove());
        
        if (currentWireMode === 'curve') {
            const curveSlider = document.getElementById('wireCurveSlider');
            const curveValue = curveSlider ? parseInt(curveSlider.value) : 0;
            createCurveWirePreview(wireStartMark, wireEndMark, curveValue);
        } else {
            createPointsWirePreview(wireStartMark, wireEndMark, wirePoints);
            createDraggablePoints();
        }
    }

    function createCurveWirePreview(startMark, endMark, curveValue = 0) {
        const transform = getImageTransform();
        if (!transform) return;
        
        const startX = startMark.x * transform.scaleX + transform.imgOffsetX + (startMark.size * transform.scaleX / 2);
        const startY = startMark.y * transform.scaleY + transform.imgOffsetY + (startMark.size * transform.scaleY / 2);
        const endX = endMark.x * transform.scaleX + transform.imgOffsetX + (endMark.size * transform.scaleX / 2);
        const endY = endMark.y * transform.scaleY + transform.imgOffsetY + (endMark.size * transform.scaleY / 2);
        
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("class", "wire-preview");
        svg.setAttribute("data-wire-type", currentWireType);
        svg.style.position = "absolute";
        svg.style.top = "0";
        svg.style.left = "0";
        svg.style.width = "100%";
        svg.style.height = "100%";
        svg.style.pointerEvents = "none";
        svg.style.zIndex = "5";
        
        const wireTypeInfo = getWireTypeInfo(currentWireType);
        const wireColor = wireTypeInfo.color;
        
        const dx = endX - startX;
        const dy = endY - startY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        let pathData;
        
        if (curveValue === 0) {
            pathData = `M ${startX} ${startY} L ${endX} ${endY}`;
        } else {
            const curveFactor = Math.abs(curveValue) / 100;
            const controlDistance = distance * 0.5 * curveFactor;
            
            if (curveValue > 0) {
                const angle = Math.atan2(dy, dx);
                const perpendicular = angle + Math.PI / 2;
                
                const controlX1 = startX + Math.cos(perpendicular) * controlDistance;
                const controlY1 = startY + Math.sin(perpendicular) * controlDistance;
                const controlX2 = endX + Math.cos(perpendicular) * controlDistance;
                const controlY2 = endY + Math.sin(perpendicular) * controlDistance;
                
                pathData = `M ${startX} ${startY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${endX} ${endY}`;
            } else {
                const angle = Math.atan2(dy, dx);
                const perpendicular = angle - Math.PI / 2;
                
                const controlX1 = startX + Math.cos(perpendicular) * controlDistance;
                const controlY1 = startY + Math.sin(perpendicular) * controlDistance;
                const controlX2 = endX + Math.cos(perpendicular) * controlDistance;
                const controlY2 = endY + Math.sin(perpendicular) * controlDistance;
                
                pathData = `M ${startX} ${startY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${endX} ${endY}`;
            }
        }
        
        const path = document.createElementNS(svgNS, "path");
        path.setAttribute("d", pathData);
        path.setAttribute("stroke", wireColor + "80");
        path.setAttribute("stroke-width", "3");
        path.setAttribute("stroke-linecap", "round");
        path.setAttribute("stroke-linejoin", "round");
        path.setAttribute("fill", "none");
        path.setAttribute("stroke-dasharray", "5,5");
        
        svg.appendChild(path);
        imgInner.appendChild(svg);
    }

    function createPointsWirePreview(startMark, endMark, points) {
        const transform = getImageTransform();
        if (!transform) return;
        
        const startX = startMark.x * transform.scaleX + transform.imgOffsetX + (startMark.size * transform.scaleX / 2);
        const startY = startMark.y * transform.scaleY + transform.imgOffsetY + (startMark.size * transform.scaleY / 2);
        const endX = endMark.x * transform.scaleX + transform.imgOffsetX + (endMark.size * transform.scaleX / 2);
        const endY = endMark.y * transform.scaleY + transform.imgOffsetY + (endMark.size * transform.scaleY / 2);
        
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("class", "wire-preview");
        svg.setAttribute("data-wire-type", currentWireType);
        svg.style.position = "absolute";
        svg.style.top = "0";
        svg.style.left = "0";
        svg.style.width = "100%";
        svg.style.height = "100%";
        svg.style.pointerEvents = "none";
        svg.style.zIndex = "5";
        
        const wireTypeInfo = getWireTypeInfo(currentWireType);
        const wireColor = wireTypeInfo.color;
        
        let pathData = `M ${startX} ${startY}`;
        
        points.forEach(point => {
            const pointX = point.x * transform.scaleX + transform.imgOffsetX;
            const pointY = point.y * transform.scaleY + transform.imgOffsetY;
            pathData += ` L ${pointX} ${pointY}`;
        });
        
        pathData += ` L ${endX} ${endY}`;
        
        const path = document.createElementNS(svgNS, "path");
        path.setAttribute("d", pathData);
        path.setAttribute("stroke", wireColor + "80");
        path.setAttribute("stroke-width", "3");
        path.setAttribute("stroke-linecap", "round");
        path.setAttribute("stroke-linejoin", "round");
        path.setAttribute("fill", "none");
        path.setAttribute("stroke-dasharray", "5,5");
        
        svg.appendChild(path);
        imgInner.appendChild(svg);
    }

    function createDraggablePoints() {
        const transform = getImageTransform();
        if (!transform) return;
        
        const wireTypeInfo = getWireTypeInfo(currentWireType);
        
        wirePoints.forEach((point, index) => {
            if (point.element && point.element.parentNode) {
                point.element.parentNode.removeChild(point.element);
            }
            
            const pointEl = document.createElement('div');
            pointEl.className = 'draggable-point';
            pointEl.dataset.pointId = point.id;
            pointEl.dataset.pointIndex = index;
            pointEl.style.position = 'absolute';
            pointEl.style.width = '16px';
            pointEl.style.height = '16px';
            pointEl.style.background = wireTypeInfo.color;
            pointEl.style.border = '2px solid white';
            pointEl.style.borderRadius = '50%';
            pointEl.style.cursor = 'move';
            pointEl.style.zIndex = '10';
            pointEl.style.boxShadow = '0 2px 6px rgba(0,0,0,0.3)';
            pointEl.style.transition = 'all 0.2s ease';
            
            const x = point.x * transform.scaleX + transform.imgOffsetX - 8;
            const y = point.y * transform.scaleY + transform.imgOffsetY - 8;
            pointEl.style.left = x + 'px';
            pointEl.style.top = y + 'px';
            
            point.element = pointEl;
            setupPointDragging(point, pointEl, index);
            
            pointEl.addEventListener('click', (e) => {
                e.stopPropagation();
            });
            
            imgInner.appendChild(pointEl);
        });
    }

    function setupPointDragging(point, pointEl, index) {
        let isDragging = false;
        let dragStartX = 0, dragStartY = 0;
        let pointStartX = 0, pointStartY = 0;
        
        pointEl.addEventListener('mousedown', (e) => {
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            pointStartX = point.x;
            pointStartY = point.y;
            pointEl.style.cursor = 'grabbing';
            pointEl.style.zIndex = '11';
            pointEl.classList.add('dragging');
            pointEl.style.transform = 'scale(1.4)';
            pointEl.style.boxShadow = '0 6px 12px rgba(0,0,0,0.5)';
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const dx = e.clientX - dragStartX;
            const dy = e.clientY - dragStartY;
            
            const transform = getImageTransform();
            if (!transform) return;
            
            const imgRect = previewImage.getBoundingClientRect();
            const scaleX = imageNaturalWidth / imgRect.width;
            const scaleY = imageNaturalHeight / imgRect.height;
            
            const imageDx = dx * scaleX;
            const imageDy = dy * scaleY;
            
            point.x = pointStartX + imageDx;
            point.y = pointStartY + imageDy;
            
            point.x = Math.max(0, Math.min(imageNaturalWidth, point.x));
            point.y = Math.max(0, Math.min(imageNaturalHeight, point.y));
            
            const newX = point.x * transform.scaleX + transform.imgOffsetX - 8;
            const newY = point.y * transform.scaleY + transform.imgOffsetY - 8;
            pointEl.style.left = newX + 'px';
            pointEl.style.top = newY + 'px';
            
            updateWirePreview();
        });
        
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                pointEl.style.cursor = 'move';
                pointEl.style.zIndex = '10';
                pointEl.classList.remove('dragging');
                pointEl.style.transform = 'scale(1.2)';
                pointEl.style.boxShadow = '0 4px 8px rgba(0,0,0,0.4)';
                updatePointsList();
            }
        });
    }

    function createWire() {
        if (!wireStartMark || !wireEndMark || !currentWireType) {
            alert('Please select two marks to connect');
            return;
        }
        
        if (wireStartMark === wireEndMark) {
            alert('Cannot connect a mark to itself');
            return;
        }
        
        const wireElement = currentWireMode === 'curve' 
            ? createCurveWire(wireStartMark, wireEndMark)
            : createPointsWire(wireStartMark, wireEndMark, wirePoints);
        
        if (!wireElement) return;
        
        const wire = {
            id: `wire-${Date.now()}`,
            startMark: wireStartMark,
            endMark: wireEndMark,
            element: wireElement,
            mode: currentWireMode,
            curveValue: currentWireMode === 'curve' ? parseInt(document.getElementById('wireCurveSlider').value) : 0,
            points: currentWireMode === 'points' ? wirePoints.map(p => ({ x: p.x, y: p.y })) : [],
            wireType: currentWireType,
            color: getWireTypeInfo(currentWireType).color
        };
        
        wires.push(wire);
        
        // IMPORTANT: Remove all point elements after wire creation
        document.querySelectorAll('.draggable-point').forEach(el => el.remove());
        wirePoints = [];
        
        updateWiresList();
        resetWireSelection();
        
        const wireTypeInfo = getWireTypeInfo(currentWireType);
        showNotification(`${wireTypeInfo.title} created between ${wireStartMark.seriesLabel} and ${wireEndMark.seriesLabel}`, 'success');
    }

    function createCurveWire(startMark, endMark) {
        const transform = getImageTransform();
        if (!transform) return null;
        
        const curveSlider = document.getElementById('wireCurveSlider');
        const curveValue = curveSlider ? parseInt(curveSlider.value) : 0;
        
        return createWireElement(startMark, endMark, curveValue, false);
    }

    function createPointsWire(startMark, endMark, points) {
        const transform = getImageTransform();
        if (!transform) return null;
        
        return createWireElementWithPoints(startMark, endMark, points, false);
    }

    function createWireElementWithPoints(startMark, endMark, points, isPreview = false) {
        const transform = getImageTransform();
        if (!transform) return null;
        
        const startX = startMark.x * transform.scaleX + transform.imgOffsetX + (startMark.size * transform.scaleX / 2);
        const startY = startMark.y * transform.scaleY + transform.imgOffsetY + (startMark.size * transform.scaleY / 2);
        const endX = endMark.x * transform.scaleX + transform.imgOffsetX + (endMark.size * transform.scaleX / 2);
        const endY = endMark.y * transform.scaleY + transform.imgOffsetY + (endMark.size * transform.scaleY / 2);
        
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("class", isPreview ? "wire-preview" : "wire");
        svg.setAttribute("data-wire-type", currentWireType);
        svg.style.position = "absolute";
        svg.style.top = "0";
        svg.style.left = "0";
        svg.style.width = "100%";
        svg.style.height = "100%";
        svg.style.pointerEvents = isPreview ? "none" : "auto";
        svg.style.zIndex = isPreview ? "5" : "9";
        
        const wireTypeInfo = getWireTypeInfo(currentWireType);
        const wireColor = wireTypeInfo.color;
        
        let pathData = `M ${startX} ${startY}`;
        
        points.forEach(point => {
            const pointX = point.x * transform.scaleX + transform.imgOffsetX;
            const pointY = point.y * transform.scaleY + transform.imgOffsetY;
            pathData += ` L ${pointX} ${pointY}`;
        });
        
        pathData += ` L ${endX} ${endY}`;
        
        const path = document.createElementNS(svgNS, "path");
        path.setAttribute("d", pathData);
        path.setAttribute("stroke", isPreview ? wireColor + "80" : wireColor);
        path.setAttribute("stroke-width", isPreview ? "3" : "4");
        path.setAttribute("stroke-linecap", "round");
        path.setAttribute("stroke-linejoin", "round");
        path.setAttribute("fill", "none");
        path.setAttribute("stroke-dasharray", isPreview ? "5,5" : "none");
        
        if (!isPreview) {
            path.style.cursor = "pointer";
            path.addEventListener('click', function(e) {
                e.stopPropagation();
                selectWire(startMark, endMark, currentWireType);
            });
            
            makeWireDraggable(path, startMark, endMark);
        }
        
        svg.appendChild(path);
        
        const startCircle = document.createElementNS(svgNS, "circle");
        startCircle.setAttribute("cx", startX);
        startCircle.setAttribute("cy", startY);
        startCircle.setAttribute("r", "6");
        startCircle.setAttribute("fill", wireColor);
        startCircle.setAttribute("stroke", "#fff");
        startCircle.setAttribute("stroke-width", "2");
        
        const endCircle = document.createElementNS(svgNS, "circle");
        endCircle.setAttribute("cx", endX);
        endCircle.setAttribute("cy", endY);
        endCircle.setAttribute("r", "6");
        endCircle.setAttribute("fill", wireColor);
        endCircle.setAttribute("stroke", "#fff");
        endCircle.setAttribute("stroke-width", "2");
        
        svg.appendChild(startCircle);
        svg.appendChild(endCircle);
        
        imgInner.appendChild(svg);
        
        return {
            svg,
            path,
            startCircle,
            endCircle,
            startX, startY, endX, endY
        };
    }

    function createWireElement(startMark, endMark, curveValue = 0, isPreview = false) {
        const transform = getImageTransform();
        if (!transform) return null;
        
        const startX = startMark.x * transform.scaleX + transform.imgOffsetX + (startMark.size * transform.scaleX / 2);
        const startY = startMark.y * transform.scaleY + transform.imgOffsetY + (startMark.size * transform.scaleY / 2);
        const endX = endMark.x * transform.scaleX + transform.imgOffsetX + (endMark.size * transform.scaleX / 2);
        const endY = endMark.y * transform.scaleY + transform.imgOffsetY + (endMark.size * transform.scaleY / 2);
        
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("class", isPreview ? "wire-preview" : "wire");
        svg.setAttribute("data-wire-type", currentWireType);
        svg.style.position = "absolute";
        svg.style.top = "0";
        svg.style.left = "0";
        svg.style.width = "100%";
        svg.style.height = "100%";
        svg.style.pointerEvents = isPreview ? "none" : "auto";
        svg.style.zIndex = isPreview ? "5" : "9";
        
        const wireTypeInfo = getWireTypeInfo(currentWireType);
        const wireColor = wireTypeInfo.color;
        
        const dx = endX - startX;
        const dy = endY - startY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        let pathData;
        
        if (curveValue === 0) {
            pathData = `M ${startX} ${startY} L ${endX} ${endY}`;
        } else {
            const curveFactor = Math.abs(curveValue) / 100;
            const controlDistance = distance * 0.5 * curveFactor;
            
            if (curveValue > 0) {
                const angle = Math.atan2(dy, dx);
                const perpendicular = angle + Math.PI / 2;
                
                const controlX1 = startX + Math.cos(perpendicular) * controlDistance;
                const controlY1 = startY + Math.sin(perpendicular) * controlDistance;
                const controlX2 = endX + Math.cos(perpendicular) * controlDistance;
                const controlY2 = endY + Math.sin(perpendicular) * controlDistance;
                
                pathData = `M ${startX} ${startY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${endX} ${endY}`;
            } else {
                const angle = Math.atan2(dy, dx);
                const perpendicular = angle - Math.PI / 2;
                
                const controlX1 = startX + Math.cos(perpendicular) * controlDistance;
                const controlY1 = startY + Math.sin(perpendicular) * controlDistance;
                const controlX2 = endX + Math.cos(perpendicular) * controlDistance;
                const controlY2 = endY + Math.sin(perpendicular) * controlDistance;
                
                pathData = `M ${startX} ${startY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${endX} ${endY}`;
            }
        }
        
        const path = document.createElementNS(svgNS, "path");
        path.setAttribute("d", pathData);
        path.setAttribute("stroke", isPreview ? wireColor + "80" : wireColor);
        path.setAttribute("stroke-width", isPreview ? "3" : "4");
        path.setAttribute("stroke-linecap", "round");
        path.setAttribute("stroke-linejoin", "round");
        path.setAttribute("fill", "none");
        path.setAttribute("stroke-dasharray", isPreview ? "5,5" : "none");
        
        if (!isPreview) {
            path.style.cursor = "pointer";
            path.addEventListener('click', function(e) {
                e.stopPropagation();
                selectWire(startMark, endMark, currentWireType);
            });
            
            makeWireDraggable(path, startMark, endMark);
        }
        
        svg.appendChild(path);
        
        const startCircle = document.createElementNS(svgNS, "circle");
        startCircle.setAttribute("cx", startX);
        startCircle.setAttribute("cy", startY);
        startCircle.setAttribute("r", "6");
        startCircle.setAttribute("fill", wireColor);
        startCircle.setAttribute("stroke", "#fff");
        startCircle.setAttribute("stroke-width", "2");
        
        const endCircle = document.createElementNS(svgNS, "circle");
        endCircle.setAttribute("cx", endX);
        endCircle.setAttribute("cy", endY);
        endCircle.setAttribute("r", "6");
        endCircle.setAttribute("fill", wireColor);
        endCircle.setAttribute("stroke", "#fff");
        endCircle.setAttribute("stroke-width", "2");
        
        svg.appendChild(startCircle);
        svg.appendChild(endCircle);
        
        imgInner.appendChild(svg);
        
        return {
            svg,
            path,
            startCircle,
            endCircle,
            startX, startY, endX, endY,
            curveValue
        };
    }

    function makeWireDraggable(pathElement, startMark, endMark) {
        let isDragging = false;
        let startDragX = 0, startDragY = 0;
        let originalStartX = 0, originalStartY = 0, originalEndX = 0, originalEndY = 0;
        
        pathElement.addEventListener('mousedown', function(e) {
            isDragging = true;
            startDragX = e.clientX;
            startDragY = e.clientY;
            
            const transform = getImageTransform();
            if (transform) {
                originalStartX = startMark.x * transform.scaleX + transform.imgOffsetX + (startMark.size * transform.scaleX / 2);
                originalStartY = startMark.y * transform.scaleY + transform.imgOffsetY + (startMark.size * transform.scaleY / 2);
                originalEndX = endMark.x * transform.scaleX + transform.imgOffsetX + (endMark.size * transform.scaleX / 2);
                originalEndY = endMark.y * transform.scaleY + transform.imgOffsetY + (endMark.size * transform.scaleY / 2);
            }
            
            e.stopPropagation();
        });
        
        document.addEventListener('mousemove', function(e) {
            if (!isDragging) return;
            
            const dx = e.clientX - startDragX;
            const dy = e.clientY - startDragY;
            
            const newStartX = originalStartX + dx;
            const newStartY = originalStartY + dy;
            const newEndX = originalEndX + dx;
            const newEndY = originalEndY + dy;
            
            const transform = getImageTransform();
            if (!transform) return;
            
            const scaleX = transform.scaleX;
            const scaleY = transform.scaleY;
            const imgOffsetX = transform.imgOffsetX;
            const imgOffsetY = transform.imgOffsetY;
            
            startMark.x = (newStartX - imgOffsetX - (startMark.size * scaleX / 2)) / scaleX;
            startMark.y = (newStartY - imgOffsetY - (startMark.size * scaleY / 2)) / scaleY;
            
            endMark.x = (newEndX - imgOffsetX - (endMark.size * scaleX / 2)) / scaleX;
            endMark.y = (newEndY - imgOffsetY - (endMark.size * scaleY / 2)) / scaleY;
            
            updateMarkPosition(startMark);
            updateMarkPosition(endMark);
            
            updateAllWires(currentWireType);
            
            e.preventDefault();
        });
        
        document.addEventListener('mouseup', function() {
            isDragging = false;
        });
    }

    function cancelWire() {
        resetWireSelection();
    }

    function selectWire(startMark, endMark, wireType) {
        selectedWire = { startMark, endMark, wireType };
        
        wires.forEach(wire => {
            if ((wire.startMark === startMark && wire.endMark === endMark && wire.wireType === wireType) ||
                (wire.startMark === endMark && wire.endMark === startMark && wire.wireType === wireType)) {
                wire.element.path.setAttribute('stroke-width', '6');
            } else {
                wire.element.path.setAttribute('stroke-width', '4');
            }
        });
        
        showWireEditOptions(startMark, endMark, wireType);
    }

    function showWireEditOptions(startMark, endMark, wireType) {
        const existingEdit = document.querySelector('.wire-edit-controls');
        if (existingEdit) {
            existingEdit.remove();
        }
        
        const wire = wires.find(w => 
            ((w.startMark === startMark && w.endMark === endMark) ||
             (w.startMark === endMark && w.endMark === startMark)) &&
            w.wireType === wireType
        );
        
        if (!wire) return;
        
        const wireTypeInfo = getWireTypeInfo(wireType);
        
        const editHTML = `
            <div class="mark-controls-box wire-edit-controls" style="margin-top: 20px; border-color: ${wireTypeInfo.color};">
                <h3 style="color: ${wireTypeInfo.color};">
                    <span class="material-icons" style="font-size: 18px; vertical-align: middle; margin-right: 8px;">edit</span>
                    Edit ${wireTypeInfo.title}
                </h3>
                
                <div class="form-group">
                    <div style="background: ${wireTypeInfo.bgColor}; padding: 12px; border-radius: 8px; margin-bottom: 16px; border: 1px solid ${wireTypeInfo.borderColor};">
                        <div style="font-size: 12px; color: ${wireTypeInfo.color}; margin-bottom: 8px;">
                            <span class="material-icons" style="font-size: 14px; vertical-align: middle; margin-right: 4px;">link</span>
                            ${wireTypeInfo.title} between <strong>${startMark.seriesLabel}</strong> and <strong>${endMark.seriesLabel}</strong>
                        </div>
                        <div style="font-size: 11px; color: #555;">
                            Mode: ${wire.mode === 'curve' ? 'Curve' : 'Points'} 
                            ${wire.mode === 'curve' ? `• Curve level: ${wire.curveValue}` : `• Points: ${wire.points.length}`}
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <button id="deleteWireBtn" class="btn full-width" style="border-color: #f44336; color: #f44336;">
                        <span class="material-icons" style="font-size: 16px; margin-right: 8px;">delete</span>
                        Delete Wire
                    </button>
                    <button id="closeEditBtn" class="btn full-width" style="margin-top: 8px;">
                        <span class="material-icons" style="font-size: 16px; margin-right: 8px;">close</span>
                        Close
                    </button>
                </div>
            </div>
        `;
        
        const wireControls = document.getElementById('wireControls');
        if (wireControls) {
            wireControls.insertAdjacentHTML('afterend', editHTML);
            
            document.getElementById('deleteWireBtn').addEventListener('click', function() {
                deleteWire(wire);
            });
            
            document.getElementById('closeEditBtn').addEventListener('click', function() {
                const editControls = document.querySelector('.wire-edit-controls');
                if (editControls) {
                    editControls.remove();
                }
                
                wires.forEach(wire => {
                    wire.element.path.setAttribute('stroke-width', '4');
                });
                
                selectedWire = null;
            });
        }
    }

    function updateWireDisplay(wire) {
        if (wire.element && wire.element.svg) {
            wire.element.svg.remove();
        }
        
        let newElement;
        if (wire.mode === 'curve') {
            const curveSlider = document.getElementById('editWireCurveSlider');
            const newCurveValue = curveSlider ? parseInt(curveSlider.value) : wire.curveValue;
            wire.curveValue = newCurveValue;
            newElement = createWireElement(wire.startMark, wire.endMark, newCurveValue, false);
        } else {
            newElement = createWireElementWithPoints(wire.startMark, wire.endMark, wire.points, false);
        }
        
        wire.element = newElement;
    }

    function updateWire(wire) {
        if (wire.mode === 'curve') {
            const slider = document.getElementById('editWireCurveSlider');
            const newCurveValue = slider ? parseInt(slider.value) : wire.curveValue;
            wire.curveValue = newCurveValue;
        }
        
        updateWireDisplay(wire);
        
        const wireTypeInfo = getWireTypeInfo(wire.wireType);
        showNotification(`${wireTypeInfo.title} updated successfully`, 'success');
    }

    function deleteWire(wire) {
        if (wire.element && wire.element.svg) {
            wire.element.svg.remove();
        }
        
        const index = wires.indexOf(wire);
        if (index > -1) {
            wires.splice(index, 1);
        }
        
        const editControls = document.querySelector('.wire-edit-controls');
        if (editControls) {
            editControls.remove();
        }
        
        updateWiresList();
        
        const wireTypeInfo = getWireTypeInfo(wire.wireType);
        showNotification(`${wireTypeInfo.title} deleted successfully`, 'success');
        selectedWire = null;
    }

    function updateAllWires(wireType = null) {
        wires.forEach(wire => {
            if (!wireType || wire.wireType === wireType) {
                if (wire.element && wire.element.svg) {
                    wire.element.svg.remove();
                }
                
                let newElement;
                if (wire.mode === 'curve') {
                    newElement = createWireElement(wire.startMark, wire.endMark, wire.curveValue, false);
                } else {
                    newElement = createWireElementWithPoints(wire.startMark, wire.endMark, wire.points, false);
                }
                wire.element = newElement;
            }
        });
    }

    function updateWiresList() {
        const wiresList = document.getElementById('wiresList');
        if (!wiresList || !currentWireType) return;
        
        wiresList.innerHTML = '';
        
        const typeWires = wires.filter(wire => wire.wireType === currentWireType);
        
        if (typeWires.length === 0) {
            const wireTypeInfo = getWireTypeInfo(currentWireType);
            wiresList.innerHTML = `<div style="color: var(--muted); font-size: 12px; text-align: center; padding: 8px;">No ${wireTypeInfo.title.toLowerCase()}s created yet</div>`;
            return;
        }
        
        typeWires.forEach((wire, index) => {
            const wireItem = document.createElement('div');
            wireItem.className = 'mark-item';
            wireItem.style.borderColor = wire.color;
            wireItem.style.background = wire.color + '10';
            
            wireItem.innerHTML = `
                <span style="flex: 1; font-size: 12px;">
                    <span style="font-weight: bold; color: ${wire.color};">${wire.startMark.seriesLabel}</span>
                    <span class="material-icons" style="font-size: 12px; vertical-align: middle; margin: 0 4px; color: ${wire.color};">arrow_forward</span>
                    <span style="font-weight: bold; color: ${wire.color};">${wire.endMark.seriesLabel}</span>
                    <span style="font-size: 10px; color: #666; margin-left: 8px;">${wire.mode === 'curve' ? 'Curve: ' + wire.curveValue : 'Points: ' + wire.points.length}</span>
                </span>
                <button class="btn" style="padding: 4px 6px; min-height: 24px; font-size: 11px; opacity: 0.7;">
                    <span class="material-icons" style="font-size: 14px;">delete</span>
                </button>
            `;
            
            wireItem.addEventListener('click', function(e) {
                if (!e.target.closest('button')) {
                    selectWire(wire.startMark, wire.endMark, wire.wireType);
                }
            });
            
            const deleteBtn = wireItem.querySelector('button');
            deleteBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                deleteWire(wire);
            });
            
            wiresList.appendChild(wireItem);
        });
    }

    /* ------------------------- MARKS & DRAGGING ------------------------- */
    const marksListEl = document.getElementById('marksList');
    const addMarkBtn = document.getElementById('addMarkBtn');
    const markShapeEl = document.getElementById('markShape');
    const markSizeEl = document.getElementById('markSizeText');

    let markCounter = 0;

    previewImage.addEventListener('load', updateImageDimensions);
    window.addEventListener('resize', updateImageDimensions);

    function getImageTransform() {
        const img = previewImage;
        const containerRect = imgContainer.getBoundingClientRect();
        const imgRect = img.getBoundingClientRect();

        imageNaturalWidth = img.naturalWidth;
        imageNaturalHeight = img.naturalHeight;

        if (!imageNaturalWidth || !imageNaturalHeight) return null;

        const imgAspect = imageNaturalWidth / imageNaturalHeight;
        const containerAspect = containerRect.width / containerRect.height;

        let displayWidth, displayHeight, imgOffsetX, imgOffsetY;

        if (imgAspect > containerAspect) {
            displayWidth = containerRect.width;
            displayHeight = containerRect.width / imgAspect;
            imgOffsetX = 0;
            imgOffsetY = (containerRect.height - displayHeight) / 2;
        } else {
            displayHeight = containerRect.height;
            displayWidth = containerRect.height * imgAspect;
            imgOffsetX = (containerRect.width - displayWidth) / 2;
            imgOffsetY = 0;
        }

        imageDisplayWidth = displayWidth;
        imageDisplayHeight = displayHeight;

        return {
            imgOffsetX,
            imgOffsetY,
            scaleX: displayWidth / imageNaturalWidth,
            scaleY: displayHeight / imageNaturalHeight
        };
    }

    function updateImageDimensions() {
        const transform = getImageTransform();
        if (transform) {
            updateAllMarks();
            updateAllWires();
        }
    }

    function updateAllMarks() {
        marks.forEach(mark => {
            updateMarkPosition(mark);
        });
    }

    function updateMarkPosition(mark) {
        const transform = getImageTransform();
        if (!transform) return;

        const x = mark.x * transform.scaleX + transform.imgOffsetX;
        const y = mark.y * transform.scaleY + transform.imgOffsetY;
        const size = mark.size * transform.scaleX;

        mark.el.style.left = x + 'px';
        mark.el.style.top = y + 'px';
        mark.el.style.width = size + 'px';
        mark.el.style.height = size + 'px';
        orientTooltip(mark);
    }

    function renumberAllMarks() {
        const marksByCode = {};
        marks.forEach(mark => {
            if (!marksByCode[mark.seriesCode]) {
                marksByCode[mark.seriesCode] = [];
            }
            marksByCode[mark.seriesCode].push(mark);
        });
        
        Object.keys(marksByCode).forEach(code => {
            marksByCode[code].sort((a, b) => {
                const numA = parseInt(a.id.split('-')[1]);
                const numB = parseInt(b.id.split('-')[1]);
                return numA - numB;
            });
            
            marksByCode[code].forEach((mark, index) => {
                const newLabel = `${code}${index + 1}`;
                
                mark.seriesLabel = newLabel;
                
                const badge = mark.el.querySelector('.label-badge');
                if (badge) {
                    badge.textContent = newLabel;
                }
            });
            
            seriesCounters[code] = marksByCode[code].length;
        });
    }

    addMarkBtn.addEventListener('click', () => {
        if (!currentProduct) {
            alert('Please select a product first');
            return;
        }
        if (currentProduct !== 'Z-WAVE RELAY' && productData[currentProduct]?.subProducts && !currentSubProduct) {
            alert('Please select a model first');
            return;
        }

        const shape = markShapeEl.value;
        let sizePercent = parseFloat(markSizeEl.value) || 4;
        if (sizePercent <= 0) sizePercent = 4;

        if (imageNaturalWidth && imageNaturalHeight) {
            const sizePixels = (sizePercent / 100) * Math.min(imageNaturalWidth, imageNaturalHeight);
            const centerX = imageNaturalWidth / 2;
            const centerY = imageNaturalHeight / 2;

            createMark({
                x: centerX - (sizePixels / 2),
                y: centerY - (sizePixels / 2),
                size: sizePixels,
                shape: shape
            });
        } else {
            createMark({
                x: 50,
                y: 50,
                size: 50,
                shape: shape
            });
        }
    });

    function createMark({ x, y, size, shape }) {
        const id = 'mark-' + (++markCounter);

        const productDataForMark = currentSubProduct && productData[currentProduct]?.subProducts?.[currentSubProduct]
            ? productData[currentProduct].subProducts[currentSubProduct]
            : null;

        if (!currentProduct) {
            alert('Please select a product first');
            return;
        }
        const needsModel = productData[currentProduct]?.subProducts && currentProduct !== 'Z-WAVE RELAY';
        if (needsModel && !currentSubProduct) {
            alert('Select a model before adding a label');
            return;
        }

        let relayItems = [];
        if (currentProduct === 'Z-WAVE RELAY') {
            relayItems = getSelectedRelayItems();
            if (relayItems.length === 0) {
                alert('Select at least one relay module and quantity');
                return;
            }
            lastRelaySelectionLabel = relayItems[relayItems.length - 1].name;
            updateRelayOverlay();
        }

        const { seriesCode, label } = nextSeriesLabel(currentProduct);
        
        const fallbackProduct = productData[currentProduct] || {};
        const fallbackImg = productDataForMark?.img || fallbackProduct.img || previewImage.src;
        const categoryName = currentProduct || '';
        let modelName = '';
        let featuresList = [];
        let descText = productDataForMark?.desc || fallbackProduct.desc || '';

        if (currentProduct === 'Z-WAVE RELAY') {
            modelName = relayItems.length === 1 ? relayItems[0].name : `${relayItems.length} modules selected`;
            featuresList = relayItems.map(item => `${item.name} — Qty ${item.quantity}`);
        } else {
            modelName = productDataForMark?.title || fallbackProduct.title || '';
            featuresList = (productDataForMark?.features || fallbackProduct.features || []).slice();
        }

        const el = document.createElement('div');
        el.className = 'mark ' + shape;
        el.dataset.id = id;
        el.dataset.size = size;
        el.dataset.shape = shape;

        const badge = document.createElement('div');
        badge.className = 'label-badge';
        badge.textContent = label;
        el.appendChild(badge);

        const tooltip = document.createElement('div');
        tooltip.className = 'tooltip';

        const tooltipContent = document.createElement('div');
        tooltipContent.className = 'tooltip-content';

        const tooltipTitle = document.createElement('div');
        tooltipTitle.className = 'tooltip-title';
        tooltipTitle.textContent = categoryName || 'Product';
        const tooltipModel = document.createElement('div');
        tooltipModel.className = 'tooltip-model';
        tooltipModel.textContent = modelName || '—';

        tooltipContent.appendChild(tooltipTitle);
        tooltipContent.appendChild(tooltipModel);
        tooltip.appendChild(tooltipContent);
        el.appendChild(tooltip);

        imgInner.appendChild(el);

        const markData = {
            id,
            x,
            y,
            size,
            shape,
            el,
            productData: productDataForMark,
            seriesCode,
            seriesLabel: label,
            tooltip,
            categoryName,
            modelName,
            desc: descText,
            features: featuresList,
            imageSrc: fallbackImg,
            relayItems
        };

        marks.push(markData);

        el.addEventListener('click', function(e) {
            if (isWireMode && currentWireType && !e.defaultPrevented) {
                if (!wireStartMark) {
                    wireStartMark = markData;
                    showNotification(`First mark selected: ${label}. Now select second mark.`, 'info');
                } else if (!wireEndMark && wireStartMark !== markData) {
                    wireEndMark = markData;
                    const wireTypeInfo = getWireTypeInfo(currentWireType);
                    showNotification(`Second mark selected: ${label}. ${currentWireMode === 'curve' ? 'Adjust curve' : 'Add points'} and click "Create ${wireTypeInfo.title}".`, 'info');
                } else if (wireStartMark === markData) {
                    wireStartMark = null;
                    wireEndMark = null;
                    wirePoints = [];
                    showNotification('First mark selection cleared.', 'info');
                } else if (wireEndMark === markData) {
                    wireEndMark = null;
                    wirePoints = [];
                    showNotification('Second mark selection cleared.', 'info');
                }
                updateWireSelectionLabels();
                updatePointsList();
                e.preventDefault();
                e.stopPropagation();
            }
        });

        let dragging = false;
        let startX = 0, startY = 0;
        let startMarkX = 0, startMarkY = 0;
        let dragStarted = false;

        function onPointerDown(ev) {
            ev.stopPropagation();
            ev.preventDefault();
            el.setPointerCapture(ev.pointerId);
            dragging = true;
            dragStarted = false;
            startX = ev.clientX;
            startY = ev.clientY;
            startMarkX = markData.x;
            startMarkY = markData.y;
            selectedMarkId = id;
            updateMarkSelection();
            el.classList.add('selected');
        }

        function onPointerMove(ev) {
            if (!dragging) return;

            const dx = ev.clientX - startX;
            const dy = ev.clientY - startY;

            if (!dragStarted && (Math.abs(dx) > 3 || Math.abs(dy) > 3)) {
                dragStarted = true;
            }

            if (!dragStarted) return;

            ev.preventDefault();
            ev.stopPropagation();

            const transform = getImageTransform();
            if (!transform || !imageNaturalWidth || !imageNaturalHeight) return;

            const imgRect = previewImage.getBoundingClientRect();

            const scaleX = imageNaturalWidth / imgRect.width;
            const scaleY = imageNaturalHeight / imgRect.height;

            const imageDx = dx * scaleX;
            const imageDy = dy * scaleY;

            let newX = startMarkX + imageDx;
            let newY = startMarkY + imageDy;

            newX = Math.max(0, Math.min(imageNaturalWidth - markData.size, newX));
            newY = Math.max(0, Math.min(imageNaturalHeight - markData.size, newY));

            markData.x = newX;
            markData.y = newY;

            updateMarkPosition(markData);
            updateAllWires();
        }

        function onPointerUp(ev) {
            if (dragging) {
                dragging = false;
                dragStarted = false;
                try {
                    el.releasePointerCapture(ev.pointerId);
                } catch (e) { }
                el.classList.remove('selected');

                if (!dragStarted && !isWireMode) {
                    selectedMarkId = id;
                    updateMarkSelection();
                    openProductModal(markData);
                }
            }
        }

        el.addEventListener('pointerdown', onPointerDown);
        el.addEventListener('mouseenter', () => orientTooltip(markData));
        document.addEventListener('pointermove', onPointerMove);
        document.addEventListener('pointerup', onPointerUp);

        updateMarkPosition(markData);
        updateMarkSelection();
    }

    function updateMarkSelection() {
        marks.forEach(m => {
            m.el.classList.toggle('selected', m.id === selectedMarkId);
        });
        renderMarksList();
    }

    function removeMark(id) {
        const idx = marks.findIndex(x => x.id === id);
        if (idx === -1) return;
        const m = marks[idx];
        
        const connectedWires = wires.filter(w => w.startMark === m || w.endMark === m);
        connectedWires.forEach(wire => {
            if (wire.element && wire.element.svg) {
                wire.element.svg.remove();
            }
            const wireIndex = wires.indexOf(wire);
            if (wireIndex > -1) {
                wires.splice(wireIndex, 1);
            }
        });
        
        if (m.el && m.el.parentNode) {
            m.el.parentNode.removeChild(m.el);
        }
        marks.splice(idx, 1);
        if (selectedMarkId === id) {
            selectedMarkId = null;
        }
        
        updateWiresList();
        renumberAllMarks();
        updateMarkSelection();
    }

    function renderMarksList() {
        marksListEl.innerHTML = '';
        if (marks.length === 0) {
            const empty = document.createElement('div');
            empty.style.color = 'var(--muted)';
            empty.style.fontSize = '12px';
            empty.style.padding = '8px';
            empty.textContent = 'No marks added yet';
            marksListEl.appendChild(empty);
            return;
        }

        marks.forEach(m => {
            const item = document.createElement('div');
            item.className = 'mark-item';
            item.classList.toggle('active', m.id === selectedMarkId);

            const label = document.createElement('span');
            label.textContent = m.seriesLabel;
            item.appendChild(label);

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'btn';
            deleteBtn.innerHTML = '<span class="material-icons" style="font-size:16px;">close</span>';
            deleteBtn.style.marginLeft = '8px';
            deleteBtn.style.padding = '4px 6px';
            deleteBtn.style.minHeight = 'auto';
            deleteBtn.style.fontSize = '12px';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                removeMark(m.id);
            });
            item.appendChild(deleteBtn);

            item.addEventListener('click', (e) => {
                if (e.target !== deleteBtn && !deleteBtn.contains(e.target)) {
                    selectedMarkId = m.id;
                    updateMarkSelection();
                    openProductModal(m);
                }
            });
            marksListEl.appendChild(item);
        });
    }

    /* ------------------------- ZOOMING ------------------------- */
    function setScale(scale) {
        imageScale = Math.max(0.3, Math.min(3, scale));

        const img = previewImage;
        const containerRect = imgContainer.getBoundingClientRect();
        const imgAspect = img.naturalWidth / img.naturalHeight;
        const containerAspect = containerRect.width / containerRect.height;

        let displayWidth, displayHeight;
        if (imgAspect > containerAspect) {
            displayWidth = containerRect.width;
            displayHeight = containerRect.width / imgAspect;
        } else {
            displayHeight = containerRect.height;
            displayWidth = containerRect.height * imgAspect;
        }

        imageDisplayWidth = displayWidth * imageScale;
        imageDisplayHeight = displayHeight * imageScale;

        imgInner.style.transform = `scale(${imageScale})`;

        requestAnimationFrame(() => {
            updateImageDimensions();
        });
    }

    imgContainer.addEventListener('wheel', (e) => {
        if (!e.ctrlKey) return;
        e.preventDefault();
        const delta = -e.deltaY / 500;
        setScale(imageScale + delta);
    });

    let pinchStartDist = 0, pinchStartScale = 1;
    imgContainer.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
            e.preventDefault();
            pinchStartDist = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            pinchStartScale = imageScale;
        }
    });

    imgContainer.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2) {
            e.preventDefault();
            const d = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            const ratio = d / pinchStartDist;
            setScale(pinchStartScale * ratio);
        }
    });

    document.getElementById('zoomReset').addEventListener('click', () => {
        setScale(1);
    });

    imgContainer.addEventListener('click', (e) => {
        if (!e.target.closest('.mark') && !e.target.closest('.wire') && !e.target.closest('.draggable-point')) {
            selectedMarkId = null;
            updateMarkSelection();
            
            if (!isWireMode) {
                resetWireSelection();
            }
        }
    });
/* ------------------------- WIRE SELECTION CLEARING FUNCTION ------------------------- */
function clearWireSelection() {
    // Clear wire mode
    isWireMode = false;
    currentWireType = null;
    
    // Reset wire selection
    wireStartMark = null;
    wireEndMark = null;
    wirePoints = [];
    selectedWire = null;
    
    // Remove all point elements
    document.querySelectorAll('.draggable-point').forEach(el => el.remove());
    
    // Remove wire preview
    const tempWire = document.querySelector('.wire-preview');
    if (tempWire) {
        tempWire.remove();
    }
    
    // Reset wire selection labels
    updateWireSelectionLabels();
    updatePointsList();
    
    // Remove active class from wire buttons
    document.querySelectorAll('.tab-btn[data-name^="KNX_WIRE"], .tab-btn[data-name^="PHASE_WIRE"], .tab-btn[data-name^="NEUTRAL_WIRE"]').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Reset wire thickness for all wires (deselect them)
    wires.forEach(wire => {
        if (wire.element && wire.element.path) {
            wire.element.path.setAttribute('stroke-width', '4');
        }
    });
    
    // Remove wire edit controls
    const wireEditControls = document.querySelector('.wire-edit-controls');
    if (wireEditControls) {
        wireEditControls.remove();
    }
    
    // Hide wire controls if they exist
    hideWireControls();
    
    // Show notification
    showNotification('Wire selection cleared', 'info');
}

    /* ------------------------- INIT ------------------------- */
    // Call this function early in initialization
    document.addEventListener('DOMContentLoaded', function() {
        // Load the floor plan image
        loadFloorPlanImage();
        
        // Build the product list
        buildList();

        // Check if image is already loaded
        if (previewImage.complete) {
            updateImageDimensions();
        } else {
            previewImage.addEventListener('load', updateImageDimensions);
        }

        // Select the first product
        const firstKey = PRODUCT_ORDER[0] || Object.keys(productData)[0];
        selectProduct(firstKey);
    });

    /* ------------------------- UTILITY FUNCTIONS ------------------------- */
    function showNotification(message, type = 'info') {
        const existingNotification = document.querySelector('.pdf-notification');
        if (existingNotification) {
            existingNotification.remove();
        }

        const notification = document.createElement('div');
        notification.className = `pdf-notification pdf-notification-${type}`;
        notification.innerHTML = `
            <span class="pdf-notification-icon">${type === 'success' ? '✓' : '⚠'}</span>
            <span class="pdf-notification-text">${message}</span>
        `;

        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            font-weight: 500;
            animation: slideInRight 0.3s ease;
        `;

        document.body.appendChild(notification);

        setTimeout(() => {
            if (notification.parentNode) {
                notification.style.animation = 'slideOutRight 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }
        }, 5000);
    }

    const style = document.createElement('style');
    style.textContent = `
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
        
        .pdf-notification-icon {
            font-weight: bold;
            font-size: 16px;
        }
        
        .draggable-point {
            transition: all 0.2s ease;
        }
        
        .draggable-point:hover {
            transform: scale(1.3);
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        }
        
        .draggable-point.dragging {
            transform: scale(1.4);
            box-shadow: 0 6px 12px rgba(0,0,0,0.5);
            cursor: grabbing;
        }
    `;
    document.head.appendChild(style);

/* ------------------------- DOWNLOAD FUNCTIONALITY ------------------------- */
/* ------------------------- PDF EXPORT FUNCTIONALITY ------------------------- */
function enhanceProductDataWithBrands() {
    const brands = {
        "DOOR LOCK": "LocPro",
        "PROCESSOR": "LUMI",
        "LUMI GLASS SERIES": "LUMI",
        "ESCULT SERIES": "Escult",
        "WALL MOUNT DISPLAY": "LUMI",
        "TACTILE HEXA SERIES": "LUMI",
        "DUO-QUAD SERIES": "LUMI",
        "DOMOGENIE GLASS LITE SERIES": "Domogenie",
        "TREMBLAY SOUNDS": "Tremblay",
        "Z-WAVE RELAY": "LUMI",
        "CURTAIN MOTORS": "LUMI",
        "SENSORS": "Big Sense",
        "AUTOMATION DISTRIBUTION BOX": "DB",       // Added
        "NETWORK DISTRIBUTION BOX": "DB"          // Added
    };

    // Add brand to all products
    for (const [category, brand] of Object.entries(brands)) {
        if (productData[category]) {
            productData[category].brand = brand;
            if (productData[category].subProducts) {
                for (const subProduct of Object.values(productData[category].subProducts)) {
                    subProduct.brand = brand;
                }
            }
        }
    }
}

// Initialize brand data
enhanceProductDataWithBrands();

// PDF Download functionality - FIXED VERSION
document.getElementById('downloadPdfBtn').addEventListener('click', async function() {
    try {
        // Show loading state
        const btn = this;
        const originalText = btn.innerHTML;
        btn.innerHTML = '<span class="material-icons" style="font-size: 16px; margin-right: 8px;">hourglass_empty</span> Generating PDF...';
        btn.disabled = true;

        // Create PDF
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
            orientation: 'portrait',
            unit: 'mm',
            format: 'a4'
        });

        // Set document properties
        doc.setProperties({
            title: 'Home Automation Configuration',
            subject: 'Product Configuration Summary',
            creator: 'Automation Configurator'
        });

        // PAGE 1: FLOOR PLAN
        doc.setFontSize(20);
        doc.setTextColor(40, 40, 40);
        doc.text('Automation Design Suite', 105, 20, { align: 'center' });

        doc.setFontSize(10);
        doc.setTextColor(100, 100, 100);
        const currentDate = new Date().toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
        doc.text(`Generated on: ${currentDate}`, 105, 28, { align: 'center' });

        let yPosition = 40;

        // Capture floor plan screenshot
        try {
            const screenshot = await captureFloorPlanScreenshot();
            if (screenshot) {
                const pageWidth = doc.internal.pageSize.getWidth();
                const margin = 20;
                const imgWidth = pageWidth - (2 * margin);
                
                // Auto height calculation based on aspect ratio
                const tempImg = new Image();
                tempImg.src = screenshot;
                await new Promise((resolve) => {
                    tempImg.onload = () => {
                        const aspectRatio = tempImg.height / tempImg.width;
                        const imgHeight = imgWidth * aspectRatio;
                        
                        // Add image to PDF
                        doc.addImage(screenshot, 'PNG', margin, yPosition, imgWidth, imgHeight);

                        // Add caption
                        doc.setFontSize(9);
                        doc.setTextColor(100, 100, 100);
                        doc.text('Floor Plan with Product Labels', 105, yPosition + imgHeight + 5, { align: 'center' });
                        yPosition = yPosition + imgHeight + 15;
                        
                        resolve();
                    };
                    tempImg.onerror = resolve; // In case image fails to load
                });
            }
        } catch (imgError) {
            console.warn('Could not capture floor plan:', imgError);
            doc.setFontSize(12);
            doc.setTextColor(150, 150, 150);
            doc.text('Floor plan image not available', 105, 80, { align: 'center' });
            yPosition = 100;
        }

        // REMOVED: Product Legend section

        // Add page number for page 1
        doc.setFontSize(8);
        doc.setTextColor(150, 150, 150);
        doc.text('Page 1 of 2', doc.internal.pageSize.getWidth() - 20, doc.internal.pageSize.getHeight() - 10, { align: 'right' });

        // PAGE 2: PRODUCT SUMMARY
        doc.addPage();
        yPosition = 30;

        // Add title
        doc.setFontSize(20);
        doc.setTextColor(40, 40, 40);
        doc.text('Product Configuration Summary', 105, yPosition, { align: 'center' });
        yPosition += 10;

        doc.setFontSize(10);
        doc.setTextColor(100, 100, 100);
        doc.text(`Generated on: ${currentDate}`, 105, yPosition, { align: 'center' });
        yPosition += 15;

        // Generate product table
        const productTable = generateProductTable();

        if (productTable.length > 0) {
            // Add summary statistics
            const totalProducts = productTable.reduce((sum, item) => sum + item.quantity, 0);
            const uniqueProducts = productTable.length;

            doc.setFontSize(11);
            doc.setTextColor(26, 115, 232);
            doc.text(`Total Items: ${totalProducts} | Unique Products: ${uniqueProducts}`, 105, yPosition, { align: 'center' });
            yPosition += 15;

            // Prepare table data
            const tableData = productTable.map(item => [
                item.label,
                item.category,
                item.brand,
                item.model,
                item.quantity.toString()
            ]);

            // Add table
            doc.autoTable({
                startY: yPosition,
                head: [['Label', 'Category', 'Brand', 'Model', 'Qty']],
                body: tableData,
                theme: 'grid',
                headStyles: {
                    fillColor: [26, 115, 232],
                    textColor: 255,
                    fontStyle: 'bold',
                    halign: 'center'
                },
                styles: {
                    fontSize: 8,
                    cellPadding: 3,
                    overflow: 'linebreak',
                    halign: 'center',
                    minCellHeight: 6
                },
                columnStyles: {
                    0: { cellWidth: 15, halign: 'center' },
                    1: { cellWidth: 50, halign: 'center' },
                    2: { cellWidth: 30, halign: 'center' },
                    3: { cellWidth: 70, halign: 'left' },
                    4: { cellWidth: 15, halign: 'center' }
                },
                margin: { left: 15 },
                didDrawPage: function (data) {
                    // Add page number
                    doc.setFontSize(8);
                    doc.setTextColor(150, 150, 150);
                    doc.text(`Page ${data.pageNumber} of ${doc.internal.getNumberOfPages()}`,
                        doc.internal.pageSize.getWidth() / 2,
                        doc.internal.pageSize.getHeight() - 10,
                        { align: 'center' });
                }
            });

            // Add footer note
            const finalY = doc.lastAutoTable.finalY || yPosition;
            if (finalY < doc.internal.pageSize.getHeight() - 30) {
                doc.setFontSize(8);
                doc.setTextColor(150, 150, 150);
                doc.text('* This is an automated configuration summary. All specifications are subject to change.',
                    105, finalY + 10, { align: 'center' });
            }
        } else {
            // No products message
            doc.setFontSize(16);
            doc.setTextColor(100, 100, 100);
            doc.text('No Products Configured', 105, 80, { align: 'center' });
            doc.setFontSize(12);
            doc.text('Add products to the floor plan to generate a summary.', 105, 95, { align: 'center' });

            // Add page number
            doc.setFontSize(8);
            doc.setTextColor(150, 150, 150);
            doc.text('Page 2 of 2', 105, doc.internal.pageSize.getHeight() - 10, { align: 'center' });
        }

        // Save PDF with timestamp
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0];
        doc.save(`home-automation-configuration-${timestamp}.pdf`);

        // Show success notification
        showNotification('PDF generated successfully!', 'success');

    } catch (error) {
        console.error('PDF generation error:', error);
        showNotification('Error generating PDF: ' + error.message, 'error');
    } finally {
        // Reset button state
        const btn = document.getElementById('downloadPdfBtn');
        btn.innerHTML = '<span class="material-icons" style="font-size: 16px; margin-right: 8px;">download</span> DOWNLOAD CONFIGURATOR PDF';
        btn.disabled = false;
    }
});

async function captureFloorPlanScreenshot() {
    try {
        const imageContainer = document.querySelector('.img-container');
        
        // Temporarily hide any notifications or overlays
        const notifications = document.querySelectorAll('.pdf-notification');
        notifications.forEach(n => n.style.visibility = 'hidden');

        const canvas = await html2canvas(imageContainer, {
            backgroundColor: '#ffffff',
            scale: 1,
            useCORS: true,
            logging: false,
            allowTaint: true,
            imageTimeout: 15000,
            onclone: function(clonedDoc) {
                // Ensure all images are loaded in the clone
                const images = clonedDoc.querySelectorAll('img');
                images.forEach(img => {
                    if (img.complete) return;
                    img.onload = function() {
                        console.log('Image loaded in clone');
                    };
                });
            }
        });

        // Restore notifications
        notifications.forEach(n => n.style.visibility = 'visible');

        return canvas.toDataURL('image/png');
    } catch (error) {
        console.error('Screenshot capture error:', error);
        
        // Create a fallback image
        const canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 600;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#f8f9fa';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#5f6368';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Floor Plan Image Not Available', canvas.width / 2, canvas.height / 2);
        ctx.font = '12px Arial';
        ctx.fillText('Please check console for errors', canvas.width / 2, canvas.height / 2 + 20);
        
        return canvas.toDataURL('image/png');
    }
}

function generateProductTable() {
    if (marks.length === 0) return [];

    const productMap = new Map();

    marks.forEach(mark => {
        const key = mark.seriesLabel;
        const category = mark.categoryName || 'Unknown';
        let model = mark.modelName || 'Unknown';
        let brand = 'LUMI'; // Default brand

        // Get brand from product data
        if (mark.categoryName && productData[mark.categoryName]) {
            brand = productData[mark.categoryName].brand || brand;
        }

        // Handle relay items
        if (category === 'Z-WAVE RELAY' && mark.relayItems && mark.relayItems.length > 0) {
            mark.relayItems.forEach(relayItem => {
                const relayKey = `${key}-${relayItem.name}`;
                if (!productMap.has(relayKey)) {
                    productMap.set(relayKey, {
                        label: key,
                        category: 'Relay Module',
                        brand: 'LUMI',
                        model: relayItem.name,
                        quantity: relayItem.quantity
                    });
                } else {
                    productMap.get(relayKey).quantity += relayItem.quantity;
                }
            });
            return; // Skip the main mark for relays
        }

        if (!productMap.has(key)) {
            productMap.set(key, {
                label: key,
                category: category,
                brand: brand,
                model: model,
                quantity: 1
            });
        } else {
            productMap.get(key).quantity += 1;
        }
    });

    // Convert to array and sort
    return Array.from(productMap.values())
        .sort((a, b) => {
            // Sort by label (S1, S2, P1, etc.)
            return a.label.localeCompare(b.label);
        });
}

function showNotification(message, type = 'info') {
    // Remove existing notification
    const existingNotification = document.querySelector('.pdf-notification');
    if (existingNotification) {
        existingNotification.remove();
    }

    const notification = document.createElement('div');
    notification.className = `pdf-notification pdf-notification-${type}`;
    notification.innerHTML = `
        <span class="pdf-notification-icon">${type === 'success' ? '✓' : '⚠'}</span>
        <span class="pdf-notification-text">${message}</span>
    `;

    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 10000;
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 14px;
        font-weight: 500;
        animation: slideInRight 0.3s ease;
    `;

    document.body.appendChild(notification);

    setTimeout(() => {
        if (notification.parentNode) {
            notification.style.animation = 'slideOutRight 0.3s ease';
            setTimeout(() => notification.remove(), 300);
        }
    }, 5000);
}

// Add CSS animations for notifications
const notificationStyle = document.createElement('style');
notificationStyle.textContent = `
    @keyframes slideInRight {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }
    
    @keyframes slideOutRight {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
    }
`;
document.head.appendChild(notificationStyle);
</script>
</body>

</html>